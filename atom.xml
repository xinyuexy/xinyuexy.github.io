<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>新月的博客</title>
  
  <subtitle>一名在读硕士的修炼之路，关注Java/Python/数据分析/数据库等 记录学习过程中的点点滴滴...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://litexy.com/"/>
  <updated>2019-02-02T11:28:02.726Z</updated>
  <id>http://litexy.com/</id>
  
  <author>
    <name>litexy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL优化实践:使用Explain分析和优化MySQL查询过程</title>
    <link href="http://litexy.com/2019/02/02/MySQL%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5-%E4%BD%BF%E7%94%A8Explain%E5%88%86%E6%9E%90%E5%92%8C%E4%BC%98%E5%8C%96MySQL%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B/"/>
    <id>http://litexy.com/2019/02/02/MySQL优化实践-使用Explain分析和优化MySQL查询过程/</id>
    <published>2019-02-02T11:45:12.000Z</published>
    <updated>2019-02-02T11:28:02.726Z</updated>
    
    <content type="html"><![CDATA[<p>最近项目中使用的数据达到了百万级别，如果不进行优化，在查询时速度就会很慢，现在想的是先在SQL语句上加上索引进行优化，但有时候MySQL并不会像我们预想的那样使用索引。MySQL提供了Explain命令能够很好地查看sql语句执行情况，是否使用了索引，查询的记录数等等。</p><h3 id="where中进行函数运算"><a href="#where中进行函数运算" class="headerlink" title="where中进行函数运算"></a>where中进行函数运算</h3><p>我在项目中需要以时间为筛选条件，如查询<code>2018-01-01</code>到<code>2018-05-31</code>之间的记录数，但我的字段的日期类型是datetime类型的(<code>2018-01-01 17:00:30</code>) ，我首先想到的是使用MySQL的<code>DATE</code>函数进行转换，SQL语句如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> lng, lat, <span class="keyword">count</span>(*) <span class="keyword">as</span> <span class="keyword">count</span> </span><br><span class="line"><span class="keyword">FROM</span> jtsg_new </span><br><span class="line"><span class="keyword">WHERE</span> <span class="built_in">DATE</span>(HRSJ) &gt;= <span class="string">'2015-01-01'</span> <span class="keyword">AND</span> <span class="built_in">DATE</span>(HRSJ) &lt;= <span class="string">'2015-05-31'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> lng, lat</span><br></pre></td></tr></table></figure></p><p>查询时间为<code>7.852</code>秒.<br>使用Explain命令对上述sql语句进行分析：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> lng, lat, <span class="keyword">count</span>(*) <span class="keyword">as</span> <span class="keyword">count</span> </span><br><span class="line"><span class="keyword">FROM</span> jtsg_new </span><br><span class="line"><span class="keyword">WHERE</span> <span class="built_in">DATE</span>(HRSJ) &gt;= <span class="string">'2015-01-01'</span> <span class="keyword">AND</span> <span class="built_in">DATE</span>(HRSJ) &lt;= <span class="string">'2015-05-31'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> lng, lat</span><br></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20181228160439235.png" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><p>我将<code>HRSJ</code>作为主键放在where里，但是通过结果发现并没有使用索引，type为ALL，key值也为null.<br>经过查询资料发现，在where字句中对索引字段进行函数运算(<code>DATE</code>)将会使MySQL放弃使用索引。于是我想的是在数据库中新增一个<code>HRSJ_DATE</code>字段将<code>HRSJ</code>的日期提取出来</p><h3 id="新增字段使用索引"><a href="#新增字段使用索引" class="headerlink" title="新增字段使用索引"></a>新增字段使用索引</h3><p>首先新增一个<code>date</code>类型字段<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> jtsg_new <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> HRSJ_DATE <span class="built_in">DATE</span></span><br></pre></td></tr></table></figure></p><p>使用<code>update</code>语句更新<code>HRSJ_DATE</code> 字段<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> jtsg_new <span class="keyword">SET</span> HRSJ_DATE = <span class="built_in">DATE</span>(HRSJ)</span><br></pre></td></tr></table></figure></p><p>增加<code>HRSJ_DATE</code>作为索引：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> jtsg_new <span class="keyword">ADD</span> <span class="keyword">INDEX</span>(HRSJ_DATE)</span><br></pre></td></tr></table></figure></p><p>最后执行查询语句：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20181228161522709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxOTAzNzMz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><br>可以看到只需要<code>0.905</code>秒时间，速度快了很多，使用Explain命令分析结果：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20181228161645798.png" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><br>type变为了<code>range</code>, 表示区间索引，key值也变为了我们的索引列, rows代表扫描的行数比之前全表扫描减少了很多。</p><p>如果将范围进一步扩大，查询12个月的记录<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20181228161924826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxOTAzNzMz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><br>结果type又变为了<code>ALL</code>, 和之前一样做全表扫描了，进一步分析明白原来MySQL中当记录数大于总表记录的百分之多少时，MySQL会放弃使用索引而进行全表扫描。</p><h3 id="强制使用索引"><a href="#强制使用索引" class="headerlink" title="强制使用索引"></a>强制使用索引</h3><p>这时可以在SQL语句中强制使用索引：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> lng, lat, <span class="keyword">count</span>(*) <span class="keyword">as</span> <span class="keyword">count</span> </span><br><span class="line"><span class="keyword">FROM</span> jtsg_new <span class="keyword">FORCE</span> <span class="keyword">INDEX</span>(HRSJ_DATE)</span><br><span class="line"><span class="keyword">WHERE</span> HRSJ_DATE &gt;= <span class="string">'2015-01-01'</span> <span class="keyword">AND</span> HRSJ_DATE &lt;= <span class="string">'2015-12-31'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> lng, lat</span><br></pre></td></tr></table></figure></p><p>分析结果如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20181228162546772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxOTAzNzMz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><br>可以看到，MySQL又使用了索引，并且查询速度也加快了不少。</p><p>这是在项目中第一次进行MySQL性能优化实践，后面还要继续深入研究MySQL的优化技巧。</p><p>参考：<br>1.<a href="https://my.oschina.net/xsh1208/blog/496254" target="_blank" rel="noopener">https://my.oschina.net/xsh1208/blog/496254</a><br>2.<a href="https://blog.csdn.net/lkforce/article/details/79148002" target="_blank" rel="noopener">https://blog.csdn.net/lkforce/article/details/79148002</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近项目中使用的数据达到了百万级别，如果不进行优化，在查询时速度就会很慢，现在想的是先在SQL语句上加上索引进行优化，但有时候MySQL并不会像我们预想的那样使用索引。MySQL提供了Explain命令能够很好地查看sql语句执行情况，是否使用了索引，查询的记录数等等。&lt;/
      
    
    </summary>
    
      <category term="MySQL" scheme="http://litexy.com/categories/MySQL/"/>
    
      <category term="项目记录" scheme="http://litexy.com/categories/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="MySQL" scheme="http://litexy.com/tags/MySQL/"/>
    
      <category term="查询优化" scheme="http://litexy.com/tags/%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Python-flask中mysql查询返回json格式数据</title>
    <link href="http://litexy.com/2019/02/02/Python-flask%E4%B8%ADmysql%E6%9F%A5%E8%AF%A2%E8%BF%94%E5%9B%9Ejson%E6%A0%BC%E5%BC%8F%E6%95%B0%E6%8D%AE/"/>
    <id>http://litexy.com/2019/02/02/Python-flask中mysql查询返回json格式数据/</id>
    <published>2019-02-02T11:42:12.000Z</published>
    <updated>2019-02-02T11:09:01.864Z</updated>
    
    <content type="html"><![CDATA[<p>在进行web项目开发时，经常需要查询数据库并返回json格式给前端，Java中可以使用JSONObject或mybatis直接就可以映射成map结构，而python中返回的是元组的形式<code>((&#39;a&#39;,1,2), (&#39;b&#39;,2,3), ...)</code>。下面提供几种在python flask中转换为json格式的方式。</p><h3 id="循环遍历"><a href="#循环遍历" class="headerlink" title="循环遍历"></a>循环遍历</h3><p>最简单粗暴的方式就是遍历结果集，使用字典进行包装，最后使用flask的jsonify将其转换为json格式，参考代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">   cur = mysql.connection.cursor()</span><br><span class="line">   cur.execute(<span class="string">'''SELECT * FROM Users WHERE id=1'''</span>)</span><br><span class="line">   rv = cur.fetchall()</span><br><span class="line">   payload = []</span><br><span class="line">   content = &#123;&#125;</span><br><span class="line">   <span class="keyword">for</span> result <span class="keyword">in</span> rv:</span><br><span class="line">       content = &#123;<span class="string">'id'</span>: result[<span class="number">0</span>], <span class="string">'username'</span>: result[<span class="number">1</span>], <span class="string">'password'</span>: result[<span class="number">2</span>]&#125;</span><br><span class="line">       payload.append(content)</span><br><span class="line">       content = &#123;&#125;</span><br><span class="line">   <span class="keyword">return</span> jsonify(payload)</span><br></pre></td></tr></table></figure></p><h3 id="直接设置Mysqldb返回字典结构"><a href="#直接设置Mysqldb返回字典结构" class="headerlink" title="直接设置Mysqldb返回字典结构"></a>直接设置Mysqldb返回字典结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db  = MySQLdb.connect(host=<span class="string">'localhost'</span>, user=<span class="string">'root'</span>, passwd=<span class="string">'123456'</span>, db=<span class="string">'test'</span>)</span><br><span class="line">cur = db.cursor(cursorclass=MySQLdb.cursors.DictCursor)</span><br></pre></td></tr></table></figure><p>只需要在最后设置cursorclass可选参数即可</p><h4 id="在flask中设置"><a href="#在flask中设置" class="headerlink" title="在flask中设置"></a>在flask中设置</h4><p>我使用的是flask-mysqldb扩展，只需要在配置中设置<code>MYSQL_CURSORCLASS=&#39;DictCursor&#39;</code>即可。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://stackoverflow.com/questions/43796423/python-converting-mysql-query-result-to-json" target="_blank" rel="noopener">https://stackoverflow.com/questions/43796423/python-converting-mysql-query-result-to-json</a></li><li><a href="http://chenxiaoyu.org/2009/11/10/python-mysqldb-return-dict/" target="_blank" rel="noopener">http://chenxiaoyu.org/2009/11/10/python-mysqldb-return-dict/</a></li><li><a href="https://stackoverflow.com/questions/38980044/looking-for-the-equivalent-of-dictcursor-in-flaskext-mysql" target="_blank" rel="noopener">https://stackoverflow.com/questions/38980044/looking-for-the-equivalent-of-dictcursor-in-flaskext-mysql</a></li><li><a href="https://flask-mysqldb.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://flask-mysqldb.readthedocs.io/en/latest/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在进行web项目开发时，经常需要查询数据库并返回json格式给前端，Java中可以使用JSONObject或mybatis直接就可以映射成map结构，而python中返回的是元组的形式&lt;code&gt;((&amp;#39;a&amp;#39;,1,2), (&amp;#39;b&amp;#39;,2,3), 
      
    
    </summary>
    
      <category term="Python" scheme="http://litexy.com/categories/Python/"/>
    
      <category term="项目记录" scheme="http://litexy.com/categories/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="flask" scheme="http://litexy.com/tags/flask/"/>
    
      <category term="MySQL" scheme="http://litexy.com/tags/MySQL/"/>
    
      <category term="Python" scheme="http://litexy.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu下安装flask-mysqldb问题记录</title>
    <link href="http://litexy.com/2019/02/02/ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85flask-mysqldb%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://litexy.com/2019/02/02/ubuntu下安装flask-mysqldb问题记录/</id>
    <published>2019-02-02T11:41:12.000Z</published>
    <updated>2019-02-02T11:09:09.945Z</updated>
    
    <content type="html"><![CDATA[<p>python中使用mysql的包有pymysql和mysqldb，同样地，flask也为其提供了扩展：flask-mysql（貌似基于pymysql），flask-mysqldb，但flask-mysql只支持python2，而flask-mysqldb同时兼容python2和python3。</p><p>在虚拟环境中安装flask-mysqldb:<br><code>pip install flask-mysqldb</code><br>出现如下错误：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20181010164239253?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxOTAzNzMz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><br>在Google中搜索<strong>OSError: mysql_config not found</strong><br>最终在Stack Overflow中找到答案(差点放弃…)<br>需要安装如下包：<br><code>sudo apt-get install libmysqlclient-dev</code><br>再次安装成功：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20181010164607804?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxOTAzNzMz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></p><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://stackoverflow.com/questions/5178292/pip-install-mysql-python-fails-with-environmenterror-mysql-config-not-found" target="_blank" rel="noopener">https://stackoverflow.com/questions/5178292/pip-install-mysql-python-fails-with-environmenterror-mysql-config-not-found</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>遇到别轻易放弃，再多找找，多尝试，相信能够成功<br>（stack overflow是个好地方）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;python中使用mysql的包有pymysql和mysqldb，同样地，flask也为其提供了扩展：flask-mysql（貌似基于pymysql），flask-mysqldb，但flask-mysql只支持python2，而flask-mysqldb同时兼容python
      
    
    </summary>
    
      <category term="Python" scheme="http://litexy.com/categories/Python/"/>
    
      <category term="项目记录" scheme="http://litexy.com/categories/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="flask" scheme="http://litexy.com/tags/flask/"/>
    
      <category term="MySQL" scheme="http://litexy.com/tags/MySQL/"/>
    
      <category term="Python" scheme="http://litexy.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Echarts结合百度地图API绘制热力图</title>
    <link href="http://litexy.com/2019/02/02/Echarts%E7%BB%93%E5%90%88%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BEAPI%E7%BB%98%E5%88%B6%E7%83%AD%E5%8A%9B%E5%9B%BE/"/>
    <id>http://litexy.com/2019/02/02/Echarts结合百度地图API绘制热力图/</id>
    <published>2019-02-02T07:42:57.664Z</published>
    <updated>2019-02-02T07:42:57.674Z</updated>
    
    <content type="html"><![CDATA[<p>最近项目中需要使用echarts与百度地图API结合来绘制事故发生热力图，在将其与百度地图结合的过程中遇到了一些问题，现将其过程与解决方案记录下，以供日后参考。echarts中结合百度地图API的热力图demo：<a href="http://gallery.echartsjs.com/editor.html?c=xSJNKs7EX" target="_blank" rel="noopener">http://gallery.echartsjs.com/editor.html?c=xSJNKs7EX</a></p><p><img src="echarts1.jpg" style="zoom: 60%"></p><a id="more"></a><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><p><strong>1.引用echarts与百度地图扩展js文件</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入百度地图的jssdk，这里需要使用你在百度地图开发者平台申请的 ak--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://api.map.baidu.com/api?v=2.0&amp;ak="</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入 ECharts --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"dist/echarts.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入百度地图扩展 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"dist/extension/bmap.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其实有个简单的方法直接在下载demo中的HTML页面即可，会以http形式引入相关文件，直接拿来用就好。</p><p><strong>2.获取dom以及echarts初始化</strong></p><p>需要获取放置地图div的dom元素，然后将echarts初始化，假如有多个js功能文件都要用到绘图的，这部分最后在主页面HTML中进行，相关代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dom = <span class="built_in">document</span>.getElementById(<span class="string">"map"</span>);</span><br><span class="line"><span class="keyword">var</span> myChart = echarts.init(dom);</span><br></pre></td></tr></table></figure><p><strong>3.设置option绘制图形</strong></p><p>使用echarts画图都需要定义好option配置项，然后调用函数进行设置，这部分最好单独放入一个函数中，方便后续其他需要绘图的调用，相关代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawHeatMap</span>(<span class="params">points</span>) </span>&#123;</span><br><span class="line"><span class="comment">//var dom = document.getElementById("contentD");</span></span><br><span class="line"><span class="comment">//var myChart = echarts.init(dom);</span></span><br><span class="line"><span class="comment">//var app = &#123;&#125;;</span></span><br><span class="line">option = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//app.title = '热力图与百度地图扩展';</span></span><br><span class="line"></span><br><span class="line">    myChart.setOption(option = &#123;</span><br><span class="line">        animation: <span class="literal">false</span>,</span><br><span class="line">        bmap: &#123;</span><br><span class="line">            center: [<span class="number">117.282699092</span>,<span class="number">31.8669422607</span>],</span><br><span class="line">            zoom: <span class="number">12</span>,</span><br><span class="line">            roam: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        visualMap: &#123;</span><br><span class="line">            show: <span class="literal">false</span>,</span><br><span class="line">            top: <span class="string">'top'</span>,</span><br><span class="line">            min: <span class="number">0</span>,</span><br><span class="line">            max: <span class="number">100</span>,</span><br><span class="line">            seriesIndex: <span class="number">0</span>,</span><br><span class="line">            calculable: <span class="literal">true</span>,</span><br><span class="line">            inRange: &#123;</span><br><span class="line">                color: [<span class="string">'blue'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>, <span class="string">'yellow'</span>, <span class="string">'red'</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        series: [&#123;</span><br><span class="line">            type: <span class="string">'heatmap'</span>,</span><br><span class="line">            coordinateSystem: <span class="string">'bmap'</span>,</span><br><span class="line">            data: points,</span><br><span class="line">            pointSize: <span class="number">5</span>,</span><br><span class="line">            blurSize: <span class="number">6</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//    if (!app.inNode) &#123;</span></span><br><span class="line"><span class="comment">//        // 添加百度地图插件</span></span><br><span class="line"><span class="comment">//        var map = myChart.getModel().getComponent('bmap').getBMap();</span></span><br><span class="line"><span class="comment">//        map.addControl(new BMap.MapTypeControl());</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (option &amp;&amp; <span class="keyword">typeof</span> option === <span class="string">"object"</span>) &#123;</span><br><span class="line">    myChart.setOption(option, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.获取百度地图扩展</strong></p><p>最后需要获取地图对象，以便后续调用百度地图API，相关代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = myChart.getModel().getComponent(<span class="string">'bmap'</span>).getBMap();</span><br><span class="line">map.addControl(<span class="keyword">new</span> BMap.MapTypeControl());</span><br><span class="line">map.centerAndZoom(<span class="string">"合肥"</span>,<span class="number">12</span>);</span><br><span class="line">map.enableScrollWheelZoom(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>注意后续如果需要使用百度地图API中的函数画图，需要每次先调用上述代码第一行获取map对象，否则无法绘制。</p><p><strong>5.最终结果</strong></p><p><img src="echarts2.jpg" style="zoom: 80%"></p><h2 id="总结与感想"><a href="#总结与感想" class="headerlink" title="总结与感想"></a>总结与感想</h2><p>（1）项目中使用的是ajax获取数据，由于Ajax是异步的，所以需要把绘图的函数放入ajax的回调函数中，不然可能在还没获取完数据时，就已经执行了绘图代码。</p><p>（2）注意引入js文件的顺序，第一次画不出来就是因为没有把百度地图ak的sj文件放到echarts前面</p><p>（3）学会发现问题，定位问题以及解决问题。其实很多代码有bug没有想象中的那复杂，很多时候主体思路和框架都对了，就是一两行细节的问题，这时就需要反复利用调式手段，不断尝试，发现问题所在，不然前面可能都功亏一篑了。</p><p>参考：<a href="https://github.com/apache/incubator-echarts/tree/master/extension/bmap" target="_blank" rel="noopener">https://github.com/apache/incubator-echarts/tree/master/extension/bmap</a></p><p><a href="http://gallery.echartsjs.com/editor.html?c=xSJNKs7EX" target="_blank" rel="noopener">http://gallery.echartsjs.com/editor.html?c=xSJNKs7EX</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近项目中需要使用echarts与百度地图API结合来绘制事故发生热力图，在将其与百度地图结合的过程中遇到了一些问题，现将其过程与解决方案记录下，以供日后参考。echarts中结合百度地图API的热力图demo：&lt;a href=&quot;http://gallery.echartsjs.com/editor.html?c=xSJNKs7EX&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://gallery.echartsjs.com/editor.html?c=xSJNKs7EX&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;echarts1.jpg&quot; style=&quot;zoom: 60%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="可视化" scheme="http://litexy.com/categories/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="echarts" scheme="http://litexy.com/tags/echarts/"/>
    
      <category term="可视化" scheme="http://litexy.com/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>我的2018个人总结与2019展望</title>
    <link href="http://litexy.com/2018/12/31/%E6%88%91%E7%9A%842018%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <id>http://litexy.com/2018/12/31/我的2018个人总结/</id>
    <published>2018-12-31T11:23:07.000Z</published>
    <updated>2018-12-31T13:01:06.363Z</updated>
    
    <content type="html"><![CDATA[<p>在2018年最后的几个小时里，我也总结一下自己在这一年里所做的主要事情，回顾一下自己一路的成长以及做这些事情对我的意义和收获，自己未来还需要做怎样地改进等等。</p><h3 id="初入项目"><a href="#初入项目" class="headerlink" title="初入项目"></a>初入项目</h3><p>我在大二大三时做过学校的创新项目，可能是意犹未尽，也可能是喜欢做项目过程中解决问题的过程以及对自己代码能力的锻炼，总之，自己心里一直对做项目充满期待，希望有一天也能独立负责一个项目。怀着这样的心情，当老师问我未来研究生道路选择时，我在项目和论文之间选择了项目。</p><p>这个项目主要是基于Web的交通事故数据分析项目，我主要负责后台部分以及地图绘图部分，主要使用的语言为Java，以及需要在MySQL数据库上进行一些操作。在此之前，我主要是使用C++做过一些东西，基本没怎么用过Java，通过这个项目，我开始边做边学Java以及数据库相关的知识，渐渐对其产生了兴趣，逐渐从C++开始转到Java，也明确了今后未来的工作方向。</p><p>当时做这个项目主要是老师说一个功能，然后我去实现，可能是自己从来没接触过相关的内容，自己回过头来看这个项目时，发现自己当时只是应付实现老师说的功能，没有调研和考虑可以加入一些好的技术，只是采用最笨最原始的方式实现，代码组织的也比较混乱。现在觉得，自己不管是在做项目还是做其他事情的过程中，不应该只满足于最基本的要求，还应该自己深入思考，将其做到极致，将自己所学的一些东西给运用进去。</p><p>希望2019对这个项目进行重构，加入一些所学的新的框架，以及挖掘项目中的难点进行优化（如大数据量查询优化），这样才算真正没有浪费之前的时间，才算是真正做了项目，将来在面试时项目准备也会比较好。</p><h3 id="我的博客之路"><a href="#我的博客之路" class="headerlink" title="我的博客之路"></a>我的博客之路</h3><p>在之前虽然也想过写博客记录一些学习笔记等，但总是不够坚持，或者总是有一种完美主义，每次都想写的很详尽很好，导致写了几篇后就基本断掉了，对写博客还是有一种不自然和畏惧心理。</p><p>研一上学期以来，自己调整了心态，摒弃了完美主义，写博客的目的很单纯，就是在记录自己的学习中遇到的问题和技术的同时，其他朋友看了也能有一些启发和帮助就更好了。现在基本每周至少更新一篇博客，包括学习笔记，项目中遇到的问题以及一些技术工具的介绍等。由于自己实力还不够，还不能够对某个技术点进行深入剖析，等到以后有积累了再写这方面的文章。</p><p>现在自己主要是在自己的<a href="litexy.com">博客网站</a>和<a href="https://blog.csdn.net/qq_31903733/article/list/1" target="_blank" rel="noopener">CSDN</a>上写博客，到现在csdn上也算是有二十多篇原创文章了，希望后面自己能够在这方面继续坚持。这也算是我的2018的另一个收获了。</p><h3 id="我的计划管理"><a href="#我的计划管理" class="headerlink" title="我的计划管理"></a>我的计划管理</h3><p>在最近，我逐渐开始明白目标计划和时间管理的重要性，于是我开始学习了GTD时间管理方法，并逐渐开始采用一些好用的软件来进行管理。</p><p>我开始列出我在这一阶段所要达成的大目标，根据大目标将其分解成一个个的具体可执行的小任务和计划，再根据这些安排每周和每天所要做的具体事情，这样一来，自己做事情就会很明确，知道这个时间点自己该做什么事，还有哪些未完成，就不会在某些时间无所事事，同时将自己的大脑清空去专心做眼下的事情。</p><p>我使用的软件主要是滴答清单，可以根据任务不同创建不同的清单，还可以创建每周和每天的任务。</p><p><img src="001.jpg" style="zoom: 60%"></p><p>同时，我也会使用keep记录下自己的临时的想法和灵感：</p><p><img src="002.jpg" style="zoom: 60%"></p><p>使用印象笔记来收藏一些好的网页文章等，有道云笔记记录自己的学习笔记。</p><p>这也是我2018一个比较大的收获，开始学会怎样更高效地学习和工作，怎样做好自己的计划管理。</p><h3 id="业余爱好"><a href="#业余爱好" class="headerlink" title="业余爱好"></a>业余爱好</h3><p>除了学习的事情之外，我也开始尝试培养自己的一些爱好和好的习惯。由于自己之前一直对乐器之类的比较感兴趣，于是在2018年开始用自己的空余时间学布鲁斯口琴，选择这个的原因主要是携带简单，噪声不大，比较喜欢口琴的这种淡淡的忧伤这种声音。但之前因为种种原因，有一段时间没练了，希望在2019年即时学习上的事情再忙，也要挤出时间来练习，也算是作为自己减压的一种方式。</p><p>另外，我也开始注重对身体的锻炼，毕竟身体才是革命的本钱，现在每天晚上回去在跟着keep上的训练计划进行锻炼。刚开始可能会比较吃力，希望自己能够一直坚持，达到自己想要的结果。</p><p>2018，我也开启了自己的阅读计划，在微信读书APP上读一些比较好的书籍，并做读书笔记和写下自己的感悟，目前在读的书有《异类》《明朝那些事儿》等，希望能够开拓自己的视野，不仅仅局限于本专业范围内。</p><h3 id="我的2019展望"><a href="#我的2019展望" class="headerlink" title="我的2019展望"></a>我的2019展望</h3><p>我们总是高估一个月所能做的事情，低估一年所能达到的目标。在即将到来的2019年，为自己写下一些未来的承诺和期许：</p><p>1.继续完善和坚持2018所坚持的事情</p><p>2.调整心态，多从自己身上找原因</p><p>3.珍惜在校学习的时间，打好基础</p><p>4.以论文为主，达到毕业要求</p><p>5.坚持坚持再坚持，克服克服再克服</p><p>期待2019遇见一个更好的自己！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在2018年最后的几个小时里，我也总结一下自己在这一年里所做的主要事情，回顾一下自己一路的成长以及做这些事情对我的意义和收获，自己未来还需要做怎样地改进等等。&lt;/p&gt;
&lt;h3 id=&quot;初入项目&quot;&gt;&lt;a href=&quot;#初入项目&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="随笔" scheme="http://litexy.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://litexy.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="总结" scheme="http://litexy.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫实战:爬取历史天气数据</title>
    <link href="http://litexy.com/2018/12/26/Python%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98-%E7%88%AC%E5%8F%96%E5%8E%86%E5%8F%B2%E5%A4%A9%E6%B0%94%E6%95%B0%E6%8D%AE/"/>
    <id>http://litexy.com/2018/12/26/Python爬虫实战-爬取历史天气数据/</id>
    <published>2018-12-26T12:40:45.000Z</published>
    <updated>2018-12-26T13:35:38.577Z</updated>
    
    <content type="html"><![CDATA[<p>最近项目需要对合肥市历史天气数据进行爬取，分析了几个天气数据网站，最终选择<a href="http://www.tianqihoubao.com/weather/top/hefei.html" target="_blank" rel="noopener">天气后报网站</a>. 将实现过程遇到的问题以及下来，供以后参考。</p><h3 id="步骤分析"><a href="#步骤分析" class="headerlink" title="步骤分析"></a>步骤分析</h3><p>这里我使用的是Python中的requests库BeautifulSoup库进行爬取，自己在实现的过程中主要可分为以下几个大步骤。</p><h4 id="1-熟悉requests库和BeautifulSoup的使用："><a href="#1-熟悉requests库和BeautifulSoup的使用：" class="headerlink" title="1.熟悉requests库和BeautifulSoup的使用："></a>1.熟悉requests库和BeautifulSoup的使用：</h4><p>requests主要是与HTTP请求相关的库，在我们的爬虫中主要用于请求获取网页很HTML内容，新手可以参考文档：<a href="http://docs.python-requests.org/zh_CN/latest/user/quickstart.html" target="_blank" rel="noopener">http://docs.python-requests.org/zh_CN/latest/user/quickstart.html</a> . </p><p>BeautifulSoup库是一个能够从HTML文件中提取数据的Python库，由于我们获取的HTML文件包含整个网页内容，我们还需要定位到我们所需要获取的数据部分，BeautifulSoup提供了包括find和find_all等一系列强大的函数帮助我们快速搜素和定位，入门教程：<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html" target="_blank" rel="noopener">https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html</a> .</p><h4 id="2-分析网页结构"><a href="#2-分析网页结构" class="headerlink" title="2.分析网页结构"></a>2.分析网页结构</h4><p>第二步我觉得是要在打开我们要爬取的网页，使用谷歌浏览器等开发者工具快速定位到我们所需要的HTML内容：</p><p><img src="001.jpg" style="zoom: 50%"></p><h4 id="3-存储数据"><a href="#3-存储数据" class="headerlink" title="3.存储数据"></a>3.存储数据</h4><p>数据获取到后需要将数据以结构化的方式存储起来，这里可以CSV文件或存储到数据库。存储的时候还需要注意的是需要提前进行预处理，避免数据有空格、换行符等特殊字符或出行中文乱码问题。</p><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><h4 id="获取网页内容"><a href="#获取网页内容" class="headerlink" title="获取网页内容"></a>获取网页内容</h4><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_soup</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(url, timeout=<span class="number">30</span>)</span><br><span class="line">        r.raise_for_status()    <span class="comment">#若请求不成功,抛出HTTPError 异常</span></span><br><span class="line">        <span class="comment">#r.encoding = 'gbk'  #与该网站编码匹配</span></span><br><span class="line">        soup = BeautifulSoup(r.text, <span class="string">'lxml'</span>)</span><br><span class="line">        <span class="keyword">return</span> soup</span><br><span class="line">    <span class="keyword">except</span> HTTPError:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Request Error"</span></span><br></pre></td></tr></table></figure><p><strong>注意点：</strong>1.若该网站编码不是utf8，而是其他的，需要<code>r.encoding</code>设置成对应的编码；2.最好进行异常处理，否则爬虫程序可能会中断。</p><h4 id="解析网页内容，得到数据"><a href="#解析网页内容，得到数据" class="headerlink" title="解析网页内容，得到数据"></a>解析网页内容，得到数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">()</span>:</span></span><br><span class="line">    soup = get_soup(url)</span><br><span class="line">    all_weather = soup.find(<span class="string">'div'</span>, class_=<span class="string">"wdetail"</span>).find(<span class="string">'table'</span>).find_all(<span class="string">"tr"</span>)</span><br><span class="line">    data = list()</span><br><span class="line">    <span class="keyword">for</span> tr <span class="keyword">in</span> all_weather[<span class="number">1</span>:]:</span><br><span class="line">        td_li = tr.find_all(<span class="string">"td"</span>)</span><br><span class="line">        <span class="keyword">for</span> td <span class="keyword">in</span> td_li:</span><br><span class="line">            s = td.get_text()</span><br><span class="line">            data.append(<span class="string">""</span>.join(s.split()))</span><br><span class="line">    res = np.array(data).reshape(<span class="number">-1</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>因为天气数据包裹在table的tr中，每个tr为一行，每一行又有4列td（日期，天气状况，气温，风力风向）</p><p><img src="002.jpg" style="zoom: 50%"></p><p>上述我把整个数据列表以4列为一组进行reshape，方便后面数据的存储，然后还将数据中空格换行符等剔除了:<code>&quot;&quot;.join(s.split())</code>。注意在解析的过程中最好多几层搜素，不要直接就得到最里面的元素，不然可能会解析不到或冲突，如<code>soup.find(&#39;div&#39;, class_=&quot;wdetail&quot;).find(&#39;table&#39;).find_all(&quot;tr&quot;)</code>而不是直接<code>soup.find_all(&quot;tr&quot;)</code></p><h4 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h4><p>最后就是数据的存储了，这里实现了存储到CSV文件和MySQL两种方式：</p><p><strong>1.CSV文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saveTocsv</span><span class="params">(data, fileName)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    将天气数据保存至csv文件</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    result_weather = pd.DataFrame(data, columns=[<span class="string">'date'</span>,<span class="string">'tq'</span>,<span class="string">'temp'</span>,<span class="string">'wind'</span>])</span><br><span class="line">    result_weather.to_csv(fileName, index=<span class="keyword">False</span>, encoding=<span class="string">'gbk'</span>)</span><br><span class="line">    print(<span class="string">'Save all weather success!'</span>)</span><br></pre></td></tr></table></figure><p><strong>2.存储到MySQL</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saveToMysql</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    将天气数据保存至MySQL数据库</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment">#建立连接</span></span><br><span class="line">    conn = pymysql.connect(host=<span class="string">"localhost"</span>, port=<span class="number">3306</span>, user=<span class="string">'root'</span>, passwd=<span class="string">'pass'</span>, database=<span class="string">'wea'</span>, charset=<span class="string">"utf8"</span>)</span><br><span class="line">    <span class="comment">#获取游标</span></span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line"></span><br><span class="line">    sql = <span class="string">"INSERT INTO weather(date,tq,temp,wind) VALUES(%s,%s,%s,%s)"</span></span><br><span class="line">    data_list = np.ndarray.tolist(data)     <span class="comment">#将numpy数组转化为列表</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        cursor.executemany(sql, data_list)</span><br><span class="line">        print(cursor.rowcount)</span><br><span class="line">        conn.commit()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line">        conn.rollback()</span><br><span class="line"></span><br><span class="line">    cursor.close()</span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure><p>存储结果如下：</p><p><img src="003.jpg" style="zoom: 50%"></p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">sys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding=<span class="string">'gb18030'</span>) <span class="comment">#改变标准输出的默认编码, 防止控制台打印乱码</span></span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://www.tianqihoubao.com/lishi/hefei/month/201812.html"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_soup</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(url, timeout=<span class="number">30</span>)</span><br><span class="line">        r.raise_for_status()    <span class="comment">#若请求不成功,抛出HTTPError 异常</span></span><br><span class="line">        <span class="comment">#r.encoding = 'gbk'  </span></span><br><span class="line">        soup = BeautifulSoup(r.text, <span class="string">'lxml'</span>)</span><br><span class="line">        <span class="keyword">return</span> soup</span><br><span class="line">    <span class="keyword">except</span> HTTPError:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Request Error"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saveTocsv</span><span class="params">(data, fileName)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    将天气数据保存至csv文件</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    result_weather = pd.DataFrame(data, columns=[<span class="string">'date'</span>,<span class="string">'tq'</span>,<span class="string">'temp'</span>,<span class="string">'wind'</span>])</span><br><span class="line">    result_weather.to_csv(fileName, index=<span class="keyword">False</span>, encoding=<span class="string">'gbk'</span>)</span><br><span class="line">    print(<span class="string">'Save all weather success!'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saveToMysql</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    将天气数据保存至MySQL数据库</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment">#建立连接</span></span><br><span class="line">    conn = pymysql.connect(host=<span class="string">"localhost"</span>, port=<span class="number">3306</span>, user=<span class="string">'root'</span>, passwd=<span class="string">'pass'</span>, database=<span class="string">'wea'</span>, charset=<span class="string">"utf8"</span>)</span><br><span class="line">    <span class="comment">#获取游标</span></span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line"></span><br><span class="line">    sql = <span class="string">"INSERT INTO weather(date,tq,temp,wind) VALUES(%s,%s,%s,%s)"</span></span><br><span class="line">    data_list = np.ndarray.tolist(data)     <span class="comment">#将numpy数组转化为列表</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        cursor.executemany(sql, data_list)</span><br><span class="line">        print(cursor.rowcount)</span><br><span class="line">        conn.commit()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line">        conn.rollback()</span><br><span class="line"></span><br><span class="line">    cursor.close()</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">()</span>:</span></span><br><span class="line">    soup = get_soup(url)</span><br><span class="line">    all_weather = soup.find(<span class="string">'div'</span>, class_=<span class="string">"wdetail"</span>).find(<span class="string">'table'</span>).find_all(<span class="string">"tr"</span>)</span><br><span class="line">    data = list()</span><br><span class="line">    <span class="keyword">for</span> tr <span class="keyword">in</span> all_weather[<span class="number">1</span>:]:</span><br><span class="line">        td_li = tr.find_all(<span class="string">"td"</span>)</span><br><span class="line">        <span class="keyword">for</span> td <span class="keyword">in</span> td_li:</span><br><span class="line">            s = td.get_text()</span><br><span class="line">            data.append(<span class="string">""</span>.join(s.split()))</span><br><span class="line"></span><br><span class="line">    res = np.array(data).reshape(<span class="number">-1</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data = get_data()</span><br><span class="line">    saveTocsv(data, <span class="string">"12.csv"</span>)</span><br></pre></td></tr></table></figure><p>参考：</p><p>1.<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html" target="_blank" rel="noopener">https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html</a></p><p>2.<a href="https://blog.csdn.net/jim7424994/article/details/22675759" target="_blank" rel="noopener">https://blog.csdn.net/jim7424994/article/details/22675759</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近项目需要对合肥市历史天气数据进行爬取，分析了几个天气数据网站，最终选择&lt;a href=&quot;http://www.tianqihoubao.com/weather/top/hefei.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;天气后报网站&lt;/
      
    
    </summary>
    
      <category term="Python" scheme="http://litexy.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://litexy.com/tags/Python/"/>
    
      <category term="爬虫" scheme="http://litexy.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>我的VSCode使用指南</title>
    <link href="http://litexy.com/2018/12/23/%E6%88%91%E7%9A%84VSCode%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://litexy.com/2018/12/23/我的VSCode使用指南/</id>
    <published>2018-12-23T11:41:12.000Z</published>
    <updated>2018-12-23T12:17:04.854Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直使用sublime text作为编辑器，但是用上了vscode后，发现其是真心好用，主要相比sublime配置简单，插件丰富，自身就内置了很多的功能，如非常友好的前端开发环境以及python等。下面主要记录一下vscode的一些简单配置和相关的开发插件。</p><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>vscode也是使用json配置文件的方式，但是其提供了可视化的操作界面，非常适合小白入门，点击左下方的设置按钮，选择Settings，用户可以搜索相关的配置项进行更改，如配置vscode编辑器字体：</p><p><img src="001.jpg" style="zoom: 60%"></p><p>同时也可以打开配置文件查看和修改：</p><p><img src="002.jpg" style="zoom: 60%"></p><p>点击扩展按钮，可以看到已安装的插件和推荐的插件</p><p><img src="003.jpg" style="zoom: 60%"></p><h3 id="主题插件"><a href="#主题插件" class="headerlink" title="主题插件"></a>主题插件</h3><p>快捷键<code>Ctrl+Shift+p</code>打开控制面板，输入theme，选择Preference：color theme，即可浏览已安装主题。</p><p><img src="004.jpg" style="zoom: 60%"></p><p>我主要安装的主题插件有：</p><p>1.Atom One Dark Theme</p><p>2.Material Theme</p><p>3.One Dark Pro</p><p>另外还有两款图标主题：</p><p>1.vscode-icons</p><p>2.Material Icon Theme</p><h3 id="前端开发插件"><a href="#前端开发插件" class="headerlink" title="前端开发插件"></a>前端开发插件</h3><p>1.Auto Close Tag</p><p>2.Bootstrap 4, Font awesome 4</p><p>3.HTML CSS Support</p><p>4.HTML Snippets</p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p><code>Ctr+Shift+p</code>打开面板后输入python可以选择python的解释器，包括虚拟环境的</p><p>1.Python:Linting, Debugging</p><p>2.Jupyter：可以实现Jupyter notebook的功能</p><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>Java Extension Pack</p><h3 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h3><p>1.Markdown All in One</p><p>2.Markdown Preview Enhanced</p><p>3.Markdown Preview Github Styling</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>1.Beautify</p><p>2.Bookmarks</p><p>3.Git History: Git提交历史信息</p><p>4.open in browser</p><p>5.Path Intellisense: 路径提示和补全</p><p>6.Project Manager: 将当前目录作为一个项目，管理多个项目</p><p><img src="005.jpg" style="zoom: 60%"></p><p>7.Settings Sync: 多个设备上同步vscode配置和插件</p><p>8.Shell launcher：配置多个终端</p><p><code>Ctrl+Shift+t</code>进行选择</p><p><img src="006.jpg" style="zoom: 60%"></p><p>9.Terminal</p><p>最后：学会用好vscode命令面板：<code>Ctrl+Shift+p</code>打开面板后，输入插件名称查看相应功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前一直使用sublime text作为编辑器，但是用上了vscode后，发现其是真心好用，主要相比sublime配置简单，插件丰富，自身就内置了很多的功能，如非常友好的前端开发环境以及python等。下面主要记录一下vscode的一些简单配置和相关的开发插件。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="工具软件" scheme="http://litexy.com/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="vscode" scheme="http://litexy.com/tags/vscode/"/>
    
      <category term="工具软件" scheme="http://litexy.com/tags/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>git使用笔记1：结合Github远程仓库管理项目</title>
    <link href="http://litexy.com/2018/10/07/git%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B01%EF%BC%9A%E7%BB%93%E5%90%88Github%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/"/>
    <id>http://litexy.com/2018/10/07/git使用笔记1：结合Github远程仓库管理项目/</id>
    <published>2018-10-07T12:02:31.000Z</published>
    <updated>2018-12-21T15:06:04.175Z</updated>
    
    <content type="html"><![CDATA[<p>git是一个十分好用的版本控制工具，我们经常在本地使用git进行项目开发，Git 并不像 SVN 那样有个中心服务器，如果想要通过 Git 分享你的代码或者与其他开发人员合作，就需要将数据放到一台其他开发人员能够连接的服务器上。我们经常使用GitHub作为远程仓库。</p><h3 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h3><p>要想将本地项目传到GitHub上，首先需要在GitHub上新建一个仓库，填入仓库名，如下图所示：<br><img src="001.png" style="zoom: 50%"></p><h3 id="本地项目与远程仓库关联"><a href="#本地项目与远程仓库关联" class="headerlink" title="本地项目与远程仓库关联"></a>本地项目与远程仓库关联</h3><p>然后就需要我们将本地项目和GitHub远程仓库关联，这里有两种选择，一种是直接克隆远程仓库，另一种是先创建本地仓库，再用命令添加。</p><h4 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h4><p><strong>1.命令如下：</strong><br><code>git clone git://github.com/xinyuexy/flask-tutorial.git</code><br>这时在本地就会出现一个flask-tutorial目录，这时该命令已经自动创建了本地的 master 分支用于跟踪远程仓库中的 master 分支。<br><strong>2.使用<code>git remote -v</code>查看如下：</strong><br><img src="002.png" style="zoom:50%"><br>可以看到一个名为origin的远程仓库。</p><h4 id="手动添加远程仓库"><a href="#手动添加远程仓库" class="headerlink" title="手动添加远程仓库"></a>手动添加远程仓库</h4><p>我们也可以选择先在本地创建一个仓库，然后与远程仓库关联。<br><strong>1.初始化仓库</strong><br>首先需要使用<code>git init</code>命令初始化，这样才会被标识为一个git项目，并创建一个本地master分支。<br><strong>2.添加远程仓库</strong><br><code>git remote add origin git://github.com/xinyuexy/flask-tutorial.git</code><br>这里添加了一个origin远程仓库与本地master关联，也可以添加多个远程仓库，比如我这里又添加一个为origin2的远程仓库<br><code>git remote add origin2 git://github.com/xinyuexy/Algorithm.git</code><br>使用<code>git remote -v</code>查看:<br><img src="003.png" style="zoom:50%"><br>可以看到现在有origin、origin2两个远程仓库了。<br><strong>3.远程仓库的删除与重命名</strong><br>也可以对远程仓库进行删除和重命名：<br>重命名：<code>git remote rename origin origin3</code><br>删除: <code>git remote rm origin2</code><br>删除后<code>git remote</code>查看：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="004.png" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></p><h3 id="提交代码到远程仓库"><a href="#提交代码到远程仓库" class="headerlink" title="提交代码到远程仓库"></a>提交代码到远程仓库</h3><p>最后就是将本地写好的代码提交的远程仓库了.<br><strong>1.<code>git add  *</code></strong><br>使用此命令跟踪所有文件，以便于后面提交<br><strong>2.<code>git status</code></strong><br>查看当前已跟踪文件<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="005.png" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><br><strong>2.<code>git commit -m &quot;init commit&quot;</code></strong><br>使用此命令提交到本地分支<br><strong>3.<code>git pull</code></strong><br>拉取远程仓库到本地，注意可能在多人开发项目时，别人可能对远程仓库进行了修改，这时如果直接提交会发生不一致错误，需要先将远程仓库最新的内容拉取到本地并合并。这条命令其实相当于<code>git fetch</code>和<code>git merge</code>的结合。<br><strong>4.<code>git push origin master</code></strong><br>终于到最后一步可以提交数据到远程仓库了。</p><h3 id="gitignore文件的使用"><a href="#gitignore文件的使用" class="headerlink" title=".gitignore文件的使用"></a>.gitignore文件的使用</h3><p>最后再补充一下关于.gitignore文件的作用。当我们使用<code>git add *</code>进行添加时，会包含很多我们不想添加的文件，这时在.gitignore文件中可以定义我们想忽略的文件内容，最后就不会提交到远程仓库，比如我的.gitignore文件内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">venv/</span><br><span class="line"></span><br><span class="line">*.pyc</span><br><span class="line">__pycache__/</span><br><span class="line"></span><br><span class="line">.idea/</span><br></pre></td></tr></table></figure></p><p>在使用python虚拟环境时，venv目录便不会提交到远程仓库，同时pycharm产生的一些文件.idea也不会提交到远程。<br>这里推荐一个自动生成.gitignore文件的网站 <a href="https://www.gitignore.io/：" target="_blank" rel="noopener">https://www.gitignore.io/：</a><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="006.png" alt="在这里插入图片描述" title="">                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><br>输入你所使用环境的关键词，点击create便能自动生成.gitignore文件了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;git是一个十分好用的版本控制工具，我们经常在本地使用git进行项目开发，Git 并不像 SVN 那样有个中心服务器，如果想要通过 Git 分享你的代码或者与其他开发人员合作，就需要将数据放到一台其他开发人员能够连接的服务器上。我们经常使用GitHub作为远程仓库。&lt;/p&gt;
      
    
    </summary>
    
      <category term="工具软件" scheme="http://litexy.com/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="Git" scheme="http://litexy.com/tags/Git/"/>
    
      <category term="Github" scheme="http://litexy.com/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>快速排序实现及其pivot的选取</title>
    <link href="http://litexy.com/2018/08/30/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%85%B6pivot%E7%9A%84%E9%80%89%E5%8F%96/"/>
    <id>http://litexy.com/2018/08/30/快速排序实现及其pivot的选取/</id>
    <published>2018-08-30T12:02:31.000Z</published>
    <updated>2019-01-09T16:06:58.097Z</updated>
    
    <content type="html"><![CDATA[<p>coursera上斯坦福的算法专项在讲到快速排序时，称其为最优雅的算法之一。快速排序确实是一种比较有效的排序算法，很多类库中也都采用了这种排序算法，其最坏时间复杂度为$O(n^2)$，平均时间复杂度为$O(nlogn)$，且其不需要额外的存储空间。</p><h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><p>快速排序主要使用了分治的思想，通过选取一个pivot，将一个数组划分为两个子数组。其步骤为：<br>1.从数组中选择一个元素作为pivot<br>2.重新排列数组，小于pivot的在pivot的左边，大于pivot的在其右边。<br>3.递归地对划分后的左右两部分重复上述步骤。</p><a id="more"></a><p>简单的伪代码如下：</p><p><img src="./01.jpg" style="zoom: 50%"></p><p>其中最主要的就是partition划分过程了。</p><h3 id="划分过程"><a href="#划分过程" class="headerlink" title="划分过程"></a>划分过程</h3><p>partition过程需要首先选择一个pivot，然后将小于pivot的元素放到左半部分，大于pivot的放到右半部分，并且最终pivot的位置及为其在排序好的数组中的最终位置。</p><p>这里使用第一个元素作为pivot，若选择其他元素作为pivot，则将其交换到第一个元素，这样可以保证代码的一致性及容易实现。示意图如下：</p><p><img src="./02.jpg" style="zoom:50%"></p><p>这里使用i和j，i和j最初为p+1的位置，在遍历的过程中i始终指向&gt;p的第一个元素，j始终指向当前待遍历的元素，若a[j] &lt; p，则将其与a[i]进行交换。相关过程如下:</p><p><img src="./03.jpg" style="zoom:50%"></p><p>基本实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* a[l+1],...,a[i-1] &lt; p</span></span><br><span class="line"><span class="comment">* a[i],...,a[j-1] &gt; p</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = a[l];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = l + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=l+<span class="number">1</span>; j&lt;=r; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[j] &lt; p) &#123;</span><br><span class="line">swap(a, j, i);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">swap(a, l, i-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> i-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">qSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="keyword">null</span> || a.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">qSort(a, <span class="number">0</span>, a.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">qSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos = partition(a, l, r);</span><br><span class="line"></span><br><span class="line">qSort(a, l, pos - <span class="number">1</span>);</span><br><span class="line">qSort(a, pos + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* a[l+1],...,a[i-1] &lt; p</span></span><br><span class="line"><span class="comment">* a[i],...,a[j-1] &gt; p</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = a[l];</span><br><span class="line"><span class="keyword">int</span> i = l + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=l+<span class="number">1</span>; j&lt;=r; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[j] &lt; p) &#123;</span><br><span class="line">swap(a, j, i);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">swap(a, l, i-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> i-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回pivot下标 选择第一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">choosePivotFirst</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = a[x];</span><br><span class="line">a[x] = a[y];</span><br><span class="line">a[y] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pivot的选取"><a href="#pivot的选取" class="headerlink" title="pivot的选取"></a>pivot的选取</h2><p>根据斯坦福算法专项课，然我们实现三种不同的pivot选取方式，并计算相应比较次数，分别为<strong>choose first, choose last, median of three</strong>, 还可以进行随机选取，这也是快速排序为什么是一种随机化算法。</p><p>pivot的选取决定了快速排序的运行时间，下面对几种特殊情况进行分析：</p><p><strong>1.最坏情况</strong></p><p>假设我们始终选取第一个元素作为pivot, 并且输入数组是有序的，那么每次划分后面所有元素都大于pivot, 每次只能将问题规模减少１，所以运行时间为$n+n-1+n-2+…+1$ = $O(n^2)$.</p><p><strong>2.最好情况</strong></p><p>最好情况为每次选取的pivot都能将数组平均地划分为两部分，由于划分的过程为$O(n)$，所以总的运行时间为$$T(n) = 2T(n/2) + O(n)$$根据主方法，时间复杂度为O(nlogn)。</p><p><strong>3.随机选取</strong></p><p>每次运行过程中，随机选取pivot, 通常能得到比较好的结果。</p><h3 id="选取方式及实现"><a href="#选取方式及实现" class="headerlink" title="选取方式及实现"></a>选取方式及实现</h3><p>斯坦福算法专项课上让我们实现三种不同的选取方式，选取第一个，最后一个，以及三数取中。</p><p><strong>1.choose first</strong></p><p>该种方式最为简单，只需返回子数组的第一个元素下标即可，下面为其实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回pivot下标 选择第一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">choosePivotFirst</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.choose last</strong></p><p>选择最后一个元素，实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择最后一个元素作为pivot</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">choosePivotLast</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.median-of-three</strong></p><p>选取第一个、最后一个以及中间的元素的中位数，如4 5 6 7, 第一个4, 最后一个7, 中间的为5, 这三个数的中位数为５, 所以选择5作为pivot，8 2 5 4 7, 三个元素分别为8 5 7, 中位数为7, 所以选择最后一个元素7作为pivot，其实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//median-of-three pivot rule</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">choosePivotMedianOfThree</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> ((r-l+<span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">mid = l + (r-l+<span class="number">1</span>)/<span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">mid = l + (r-l+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只需要找出中位数即可，不需要交换</span></span><br><span class="line">    <span class="comment">//有的版本也可以进行交换</span></span><br><span class="line"><span class="keyword">if</span> (((a[l]-a[mid]) * (a[l]-a[r])) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (((a[mid]-a[l]) * (a[mid]-a[r])) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的划分过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="comment">//pivot选择方式</span></span><br><span class="line"><span class="comment">//int pi = choosePivotFirst(a, l, r);</span></span><br><span class="line"><span class="comment">//int pi = choosePivotLast(a, l, r);</span></span><br><span class="line"><span class="keyword">int</span> pi = choosePivotMedianOfThree(a, l, r);</span><br><span class="line"></span><br><span class="line"><span class="comment">//始终将第一个元素作为pivot, 若不是, 则与之交换</span></span><br><span class="line"><span class="keyword">if</span> (pi != l) &#123;</span><br><span class="line">swap(a, pi, l);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> p = a[l];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = l + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=l+<span class="number">1</span>; j&lt;=r; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[j] &lt; p) &#123;</span><br><span class="line">swap(a, j, i);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">swap(a, l, i-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> i-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意最后的划分过程相比于之前增加的pivot的选取方式，而不是单纯地将第一个元素作为pivot, 可以看到，若第一个元素不是pivot, 需要将pivot与第一个元素进行交换，这样保证代码的统一性。</p><h2 id="总结与感想"><a href="#总结与感想" class="headerlink" title="总结与感想"></a>总结与感想</h2><p>1.学会体会这些算法背后的思想，为什么要这样设计</p><p>2.对于比较复杂的算法，学会使用特殊情况进行分析</p><p>参考资料:</p><p>(1) coursera斯坦福算法专项课part1</p><p>(2) <a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">维基百科快速排序</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;coursera上斯坦福的算法专项在讲到快速排序时，称其为最优雅的算法之一。快速排序确实是一种比较有效的排序算法，很多类库中也都采用了这种排序算法，其最坏时间复杂度为$O(n^2)$，平均时间复杂度为$O(nlogn)$，且其不需要额外的存储空间。&lt;/p&gt;
&lt;h2 id=&quot;基本步骤&quot;&gt;&lt;a href=&quot;#基本步骤&quot; class=&quot;headerlink&quot; title=&quot;基本步骤&quot;&gt;&lt;/a&gt;基本步骤&lt;/h2&gt;&lt;p&gt;快速排序主要使用了分治的思想，通过选取一个pivot，将一个数组划分为两个子数组。其步骤为：&lt;br&gt;1.从数组中选择一个元素作为pivot&lt;br&gt;2.重新排列数组，小于pivot的在pivot的左边，大于pivot的在其右边。&lt;br&gt;3.递归地对划分后的左右两部分重复上述步骤。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://litexy.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://litexy.com/tags/Algorithm/"/>
    
      <category term="QuickSort" scheme="http://litexy.com/tags/QuickSort/"/>
    
  </entry>
  
  <entry>
    <title>大整数相乘问题总结以及Java实现</title>
    <link href="http://litexy.com/2018/08/23/%E5%A4%A7%E6%95%B4%E6%95%B0%E7%9B%B8%E4%B9%98%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E4%BB%A5%E5%8F%8AJava%E5%AE%9E%E7%8E%B0/"/>
    <id>http://litexy.com/2018/08/23/大整数相乘问题总结以及Java实现/</id>
    <published>2018-08-23T12:02:31.000Z</published>
    <updated>2019-01-09T16:12:40.511Z</updated>
    
    <content type="html"><![CDATA[<p>最近在跟coursera上斯坦福大学的算法专项课，其中开篇提到了两个整数相乘的问题，其中最简单的方法就是模拟我们小学的整数乘法，可想而知这不是比较好的算法，这门课可以说非常棒，带领我们不断探索更优的算法，然后介绍可以通过使用分而治之的思想来解决这个问题。下面对该问题的方法以及实现进行介绍。</p><h2 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h2><blockquote><p> 输入：2个n位的整数x和y <br>输出：x * y</p><p> 如求: 1234567891011121314151617181*2019181716151413121110987654 的结果</p></blockquote><a id="more"></a><p>求解该问题要注意的是由于整数的位数可能超过基本类型的表示范围，所以一种方式是将其转化为字符串进行表示，另一种方式是可以使用一些语言自带的大整数类型（如Java的BigInteger）。参考一些资料才发现，该问题的解法其实有很多种，主要列举以下：</p><p><strong>１．模拟小学乘法：</strong> 竖式乘法累加。<br><strong>２．分治乘法：</strong> 最简单的是Karatsuba乘法，一般化以后有Toom-Cook乘法.<br><strong>３．快速傅里叶变换</strong><br><strong>４．中国剩余定理</strong> </p><p>我们主要介绍模拟乘法累加以及使用分治思想的Karatsuba乘法，最后使用Java进行实现。</p><h2 id="模拟小学乘法"><a href="#模拟小学乘法" class="headerlink" title="模拟小学乘法"></a>模拟小学乘法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      7 8 9 6 5 2</span><br><span class="line">×         3 2 1 1</span><br><span class="line">-----------------</span><br><span class="line">      7 8 9 6 5 2   &lt;---- 第1趟 </span><br><span class="line">    7 8 9 6 5 2     &lt;---- 第2趟 </span><br><span class="line">   ..........       &lt;---- 第n趟 </span><br><span class="line">-----------------</span><br><span class="line">  ? ? ? ? ? ? ? ?   &lt;---- 最后的值用另一个数组表示</span><br></pre></td></tr></table></figure><p>如上所示，需要将乘数与被乘数逐位相乘，最后再进行累加，时间复杂度为${O(n^2)}$.模拟乘法累加还有一个改进版，上述方法在实现时，每次计算乘法都需要考虑进位，最后在加法时也需要进位，比较麻烦。一种改进的版本如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        9  8</span><br><span class="line">×       2  1</span><br><span class="line">-------------</span><br><span class="line">       (9)(8)  &lt;---- 第1趟: 98×1的每一位结果 </span><br><span class="line">  (18)(16)     &lt;---- 第2趟: 98×2的每一位结果 </span><br><span class="line">-------------</span><br><span class="line">  (18)(25)(8)  &lt;---- 这里就是相对位的和，还没有累加进位</span><br></pre></td></tr></table></figure></p><p>改进的方法先不算任何的进位，也就是说，将每一位相乘，相加的结果保存到同一个位置，到最后才计算进位。我们可以先将结果保存到一个数组中（不考虑进位），最后对数组从右向左进行遍历，大于10进行进位。Java实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigNumMul</span> </span>&#123;</span><br><span class="line">    <span class="comment">//simple method 模拟乘法累加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">bigNumberMul</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 分配一个空间，用来存储运算的结果，num1长的数 * num2长的数，结果不会超过num1+num2长</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[num1.length() + num2.length()];</span><br><span class="line">        <span class="comment">// 先不考虑进位问题，根据竖式的乘法运算，num1的第i位与num2的第j位相乘，结果应该存放在结果的第i+j位上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = num1.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;num2.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> b = num2.charAt(j) - <span class="string">'0'</span>;</span><br><span class="line">                res[i+j] += a * b;      <span class="comment">//max: num1.length()+num2.length()-2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//单独处理进位</span></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//最多就到res.length-2, 最后一个元素没有被占用，还是初始值0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=res.length-<span class="number">2</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">            <span class="keyword">int</span> digit = (res[k] + carry) % <span class="number">10</span>;</span><br><span class="line">            carry = (res[k] + carry) / <span class="number">10</span>;</span><br><span class="line">            sb.insert(<span class="number">0</span>, digit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sb.insert(<span class="number">0</span>, carry);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String str = sb.toString().replaceFirst(<span class="string">"^0*"</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> str.substring(<span class="number">0</span>,str.length()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>显然使用$O(n^2)$的算法是不够好的，我们应该想一下有没有更好的算法，就像这门课上经常说的一句：<code>Can we do better ?</code></p><h2 id="分治：Karatsuba算法"><a href="#分治：Karatsuba算法" class="headerlink" title="分治：Karatsuba算法"></a>分治：Karatsuba算法</h2><p>分治算法的主要思想是能将问题分解为输入规模更小的子问题，然后递归求解子问题，最后将子问题的结果合并得到原问题的结果，最典型的如归并排序算法。为了得到规模更小的子问题，就要将较大的整数拆分为位数较少的两个整数，参考coursera上的算法专项课，主要计算过程如下：</p><p><img src="./01.jpg" style="zoom: 50%"> </p><p>如上图所示，将每个数分别拆分为两部分，分别计算ac, bd, 以及(a+b)(c+d)，最后再减去前面两个，将其组合成最终的结果。我们采用更一般的方式将其表达出来，相应计算方法如下：</p><p><img src="./02.jpg" style="zoom:50%"></p><p>上述给出了更通用的写法，将ｘ和ｙ同分解后的更小的整数进行表示，最后通过递归的计算ac, ad, bc, bd就可以得到x*y的结果。上述是没有优化过的分治算法，每次递归需要４次乘法，合并结果需要O(n)时间复杂度，所以可以得到时间复杂度的表示：</p><p>$${T(n) = 4T(n/2) + O(n)}$$</p><p>通过主方法，可以求得上述时间复杂度为$O(n^2)$，并没有得到好的改善。</p><p>Karatsuba算法将上述的４次乘法优化为３次从而减少了时间复杂度。具体过程如下：<br><img src="./03.jpg" style="zoom: 50%"></p><p>可以看到上述利用(a+b)(c+d)的结果减去ac和bd得到ad+bc的结果，从而只需要计算三次乘法，其时间复杂度可以表示为：</p><p>$$T(n)=3T(n/2)+6n=O(n^{log_{2}3})$$</p><p>根据上述算法，使用Java进行实现代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Karatsuba乘法</span></span><br><span class="line"><span class="comment">//此种情况使用long时,数过大可能出现越界,应考虑使用BigInteger</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">karatsuba</span><span class="params">(<span class="keyword">long</span> num1, <span class="keyword">long</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (num1 &lt; <span class="number">10</span> || num2 &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 * num2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算拆分长度</span></span><br><span class="line">    <span class="keyword">int</span> size1 = String.valueOf(num1).length();</span><br><span class="line">    <span class="keyword">int</span> size2 = String.valueOf(num2).length();</span><br><span class="line">    <span class="keyword">int</span> halfN = Math.max(size1, size2) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 拆分为a, b, c, d */</span></span><br><span class="line">    <span class="keyword">long</span> a = Long.valueOf(String.valueOf(num1).substring(<span class="number">0</span>, size1-halfN));</span><br><span class="line">    <span class="keyword">long</span> b = Long.valueOf(String.valueOf(num1).substring(size1-halfN));</span><br><span class="line">    <span class="keyword">long</span> c = Long.valueOf(String.valueOf(num2).substring(<span class="number">0</span>, size2-halfN));</span><br><span class="line">    <span class="keyword">long</span> d = Long.valueOf(String.valueOf(num2).substring(size2-halfN));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算z2, z0, z1, 此处的乘法使用递归</span></span><br><span class="line">    <span class="keyword">long</span> z1 = karatsuba(a, c);</span><br><span class="line">    <span class="keyword">long</span> z2 = karatsuba(b, d);</span><br><span class="line">    <span class="keyword">long</span> z3 = karatsuba((a + b), (c + d)) - z1 - z2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">long</span>)(z1 * Math.pow(<span class="number">10</span>, <span class="number">2</span>*halfN) + z2 + z3 * Math.pow(<span class="number">10</span>, halfN));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意上述递归的终止条件以及如何表示a, b, c, d. 上述实现使用的是Java中的long类型，但是当整数变大时，使用long类型可能会发生溢出，这里可以使用String来模拟整数的加法及乘法，或者使用Java的BigInteger类型，其实BigInteger内部也是使用的String进行存储，我使用的是BigInteger类型，实现代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用BigInteger的karatsuba算法</span></span><br><span class="line"> <span class="comment">//注意BigInteger的运算没有操作符重载</span></span><br><span class="line"> <span class="comment">//参考: coursera算法专项1</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigInteger <span class="title">karatsuba</span><span class="params">(BigInteger num1, BigInteger num2)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (num1.compareTo(BigInteger.valueOf(<span class="number">10</span>)) &lt; <span class="number">0</span> || num2.compareTo(BigInteger.valueOf(<span class="number">10</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> num1.multiply(num2);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> n = Math.max(num1.toString().length(), num2.toString().length());</span><br><span class="line">     <span class="keyword">int</span> halfN = n / <span class="number">2</span> + n % <span class="number">2</span>;  <span class="comment">//另一种划分方法</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//返回num1 / halfN 和 num1 % halfN</span></span><br><span class="line">     BigInteger[] a_b = num1.divideAndRemainder(BigInteger.valueOf(<span class="number">10</span>).pow(halfN));</span><br><span class="line">     BigInteger a = a_b[<span class="number">0</span>];</span><br><span class="line">     BigInteger b = a_b[<span class="number">1</span>];</span><br><span class="line">     BigInteger[] c_d = num2.divideAndRemainder(BigInteger.valueOf(<span class="number">10</span>).pow(halfN));</span><br><span class="line">     BigInteger c = c_d[<span class="number">0</span>];</span><br><span class="line">     BigInteger d = c_d[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">     BigInteger step1 = karatsuba(a, c);</span><br><span class="line">     BigInteger step2 = karatsuba(b, d);</span><br><span class="line">     BigInteger step3 = karatsuba(a.add(b), c.add(d));</span><br><span class="line">     BigInteger step4 = step3.subtract(step2).subtract(step1);   <span class="comment">//step3-step2-step1</span></span><br><span class="line">     BigInteger res = step1.multiply(BigInteger.valueOf(<span class="number">10</span>).pow(<span class="number">2</span>*halfN)).add(step2)</span><br><span class="line">             .add(step4.multiply(BigInteger.valueOf(<span class="number">10</span>).pow(halfN)));</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>最后的测试代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    String a = sc.next();</span><br><span class="line">    String b = sc.next();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始计算</span></span><br><span class="line">    <span class="comment">//String str = BigNumMul.bigNumberMul(a, b);</span></span><br><span class="line">    <span class="comment">//long res = BigNumMul.karatsuba(Long.valueOf(a), Long.valueOf(b));</span></span><br><span class="line">    <span class="comment">//String str = Long.toString(res);</span></span><br><span class="line">    BigInteger res = BigNumMul.karatsuba(<span class="keyword">new</span> BigInteger(a), <span class="keyword">new</span> BigInteger(b));</span><br><span class="line">    String str = res.toString();</span><br><span class="line">    System.out.println(a + <span class="string">" * "</span> + b + <span class="string">" = "</span> + str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结与感想"><a href="#总结与感想" class="headerlink" title="总结与感想"></a>总结与感想</h2><p>（1）对一个问题要深入调研和分析，多尝试不同的解决方法。</p><p>（2）可以多分析一些诸如此类的经典问题，还是比较有意思的。</p><p>参考资料：</p><p>1.<a href="https://www.coursera.org/learn/algorithms-divide-conquer/home/welcome" target="_blank" rel="noopener">coursera算法专项</a></p><p>2.<a href="https://itimetraveler.github.io/2017/08/22/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%A4%A7%E6%95%B0%E7%9B%B8%E4%B9%98%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E9%AB%98%E6%95%88%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">大数乘法问题及其高效算法</a></p><p>3.<a href="https://stackoverflow.com/questions/17531042/karatsuba-algorithm-without-biginteger-usage" target="_blank" rel="noopener">https://stackoverflow.com/questions/17531042/karatsuba-algorithm-without-biginteger-usage</a></p><p>4.<a href="https://chenyvehtung.github.io/2017/03/02/about-multiplication.html" target="_blank" rel="noopener">https://chenyvehtung.github.io/2017/03/02/about-multiplication.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在跟coursera上斯坦福大学的算法专项课，其中开篇提到了两个整数相乘的问题，其中最简单的方法就是模拟我们小学的整数乘法，可想而知这不是比较好的算法，这门课可以说非常棒，带领我们不断探索更优的算法，然后介绍可以通过使用分而治之的思想来解决这个问题。下面对该问题的方法以及实现进行介绍。&lt;/p&gt;
&lt;h2 id=&quot;问题定义&quot;&gt;&lt;a href=&quot;#问题定义&quot; class=&quot;headerlink&quot; title=&quot;问题定义&quot;&gt;&lt;/a&gt;问题定义&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 输入：2个n位的整数x和y &lt;br&gt;输出：x * y&lt;/p&gt;
&lt;p&gt; 如求: 1234567891011121314151617181*2019181716151413121110987654 的结果&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://litexy.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://litexy.com/tags/Algorithm/"/>
    
      <category term="Java" scheme="http://litexy.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>关于Java中基类构造器的调用问题</title>
    <link href="http://litexy.com/2018/08/16/%E5%85%B3%E4%BA%8Ejava%E4%B8%AD%E5%9F%BA%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E8%B0%83%E7%94%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://litexy.com/2018/08/16/关于java中基类构造器的调用问题/</id>
    <published>2018-08-16T12:02:31.000Z</published>
    <updated>2018-10-04T13:02:56.219Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在《Java编程思想》第７章复用类中有这样一段话，值得深思。当子类继承了父类时，就涉及到了基类和导出类（子类）这两个类。从外部来看，导出类就像是一个与基类具有相同接口的新类，或许还会有一些额外的方法和域。但继承并不只是复制基类的接口。当创建一个导出类对象时，该对象包含了一个基类的子对象，这个子对象与你用基类直接创建的对象是一样的，二者区别在于，后者来自于外部，而基类的子对象是被包裹在导出类对象内部。</p></blockquote><p>这就引发出了一个很重要的问题，对基类子对象的正确初始化也是至关重要的（我们可能在子类的使用基类中继承的方法和域），而且也仅有一种方法来保证这一点：在子类构造器中调用基类构造器来执行初始化。</p><a id="more"></a><h2 id="无参的基类构造器"><a href="#无参的基类构造器" class="headerlink" title="无参的基类构造器"></a>无参的基类构造器</h2><p>我们知道，当一个类你没有给他构造函数，Java会自动帮你调用无参的构造器，同时Java也会在导出类的构造器中插入对基类构造器的调用。下面的代码说明了这个工作机制：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: reusing/Cartoon.java</span></span><br><span class="line"><span class="comment">// Constructor calls during inheritance.</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Art</span> </span>&#123;</span><br><span class="line">  Art() &#123; print(<span class="string">"Art constructor"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drawing</span> <span class="keyword">extends</span> <span class="title">Art</span> </span>&#123;</span><br><span class="line">  Drawing() &#123; print(<span class="string">"Drawing constructor"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cartoon</span> <span class="keyword">extends</span> <span class="title">Drawing</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Cartoon</span><span class="params">()</span> </span>&#123; print(<span class="string">"Cartoon constructor"</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Cartoon x = <span class="keyword">new</span> Cartoon();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Art constructor</span></span><br><span class="line"><span class="comment">Drawing constructor</span></span><br><span class="line"><span class="comment">Cartoon constructor</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure></p><p>观察上述代码的运行结果，在创建Cartoon对象时，会先调用其父类Drawing的构造器，而其父类又继承自Art类，所以又会调用Art类的构造器，就像层层往上。虽然在其构造器中都没有显式调用其父类构造器，但是Java会自动调用其父类的构造器。即使不为Cartoon()创建构造器，编译器也会合成一个默认的无参构造器，该构造器将调用基类的构造器。</p><h2 id="带参数的基类构造器"><a href="#带参数的基类构造器" class="headerlink" title="带参数的基类构造器"></a>带参数的基类构造器</h2><p>当基类中的构造器都是带有参数时，编译器就不会自动调用，必须用关键字super显式地调用基类构造器，并且传入适当的参数，相应的例子代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: reusing/Chess.java</span></span><br><span class="line"><span class="comment">// Inheritance, constructors and arguments.</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> net.mindview.util.Print.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">  Game(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    print(<span class="string">"Game constructor"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoardGame</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">  BoardGame(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">super</span>(i);</span><br><span class="line">    print(<span class="string">"BoardGame constructor"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chess</span> <span class="keyword">extends</span> <span class="title">BoardGame</span> </span>&#123;</span><br><span class="line">  Chess() &#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="number">11</span>);</span><br><span class="line">    print(<span class="string">"Chess constructor"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Chess x = <span class="keyword">new</span> Chess();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Game constructor</span></span><br><span class="line"><span class="comment">BoardGame constructor</span></span><br><span class="line"><span class="comment">Chess constructor</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure></p><p>从上述代码中可以观察到，必须在子类Chess构造器中显示的使用super调用父类构造器并传入适当参数。而且，调用基类构造器必须是在子类构造器中做的第一件事。</p><h2 id="基类构造器的调用顺序问题"><a href="#基类构造器的调用顺序问题" class="headerlink" title="基类构造器的调用顺序问题"></a>基类构造器的调用顺序问题</h2><p>在此之前，我们先来探讨一下<strong>对象引用的初始化问题</strong>。在Java中，类中域为基本类型时能够自动被初始化为零，但是对象引用会被初始化为null。我们往往需要在合适的位置对其进行初始化，下面是几个可以进行初始化的位置：</p><p>1.在定义对象的地方。<strong>这意味着它们总是能够在构造器被调用之前被初始化</strong>。</p><p>2.在类的构造器中。</p><p>3.就在正要使用这些对象之前，这种方式称为惰性初始化。</p><p>记住上面的第１点，下面看一个比较复杂的例子来看一下基类构造器的调用顺序问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reusing/Ex7/C7.java</span></span><br><span class="line"><span class="comment">// TIJ4 Chapter Reusing, Exercise 7, page 246</span></span><br><span class="line"><span class="comment">/* Modify Exercise 5 so that A and B have constructors with arguments instead</span></span><br><span class="line"><span class="comment">* of default constructors. Write a constructor for C and perform all </span></span><br><span class="line"><span class="comment">* initialization within C's constructor. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.greggordon.tools.Print.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; </span><br><span class="line">A(<span class="keyword">char</span> c, <span class="keyword">int</span> i) &#123; println(<span class="string">"A(char, int)"</span>);&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123; </span><br><span class="line">B(String s, <span class="keyword">float</span> f)&#123;</span><br><span class="line"><span class="keyword">super</span>(<span class="string">' '</span>, <span class="number">0</span>); </span><br><span class="line">println(<span class="string">"B(String, float)"</span>);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C7</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">C7(<span class="keyword">char</span> a, <span class="keyword">int</span> j) &#123; </span><br><span class="line"><span class="keyword">super</span>(a, j); </span><br><span class="line">c = a;</span><br><span class="line">i = j;</span><br><span class="line">&#125;</span><br><span class="line">B b = <span class="keyword">new</span> B(<span class="string">"hi"</span>, <span class="number">1f</span>); <span class="comment">// will then construct another A and then a B</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">C7 c = <span class="keyword">new</span> C7(<span class="string">'b'</span>, <span class="number">2</span>); <span class="comment">// will construct an A first</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述这段代码输出：</p><p>A(char, int)</p><p>A(char, int)</p><p>B(String, float)</p><h4 id="注意基类构造器、子类构造器、类的成员对象初始化的顺序："><a href="#注意基类构造器、子类构造器、类的成员对象初始化的顺序：" class="headerlink" title="注意基类构造器、子类构造器、类的成员对象初始化的顺序："></a>注意基类构造器、子类构造器、类的成员对象初始化的顺序：</h4><p>１．在new一个类的对象时，首先调用其父类构造器(可以是无参的和有参的，无参的系统会自动调用，有参的需要自己指定)。如上述C7中的super(a, j)</p><p>２．然后执行其成员对象初始化语句，调用B类构造器，如上述中的<br>B b = new B(“hi”, 1f)，而B的构造器又会先调用基类A的构造器。</p><p>３．最后返回到C7中的构造器，继续执行c=a,i=j。</p><p>参考：</p><p>Java编程思想复用类练习７</p><p><a href="https://www.zhihu.com/question/49196023" target="_blank" rel="noopener">https://www.zhihu.com/question/49196023</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在《Java编程思想》第７章复用类中有这样一段话，值得深思。当子类继承了父类时，就涉及到了基类和导出类（子类）这两个类。从外部来看，导出类就像是一个与基类具有相同接口的新类，或许还会有一些额外的方法和域。但继承并不只是复制基类的接口。当创建一个导出类对象时，该对象包含了一个基类的子对象，这个子对象与你用基类直接创建的对象是一样的，二者区别在于，后者来自于外部，而基类的子对象是被包裹在导出类对象内部。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这就引发出了一个很重要的问题，对基类子对象的正确初始化也是至关重要的（我们可能在子类的使用基类中继承的方法和域），而且也仅有一种方法来保证这一点：在子类构造器中调用基类构造器来执行初始化。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://litexy.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://litexy.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Java" scheme="http://litexy.com/tags/Java/"/>
    
      <category term="Java编程思想" scheme="http://litexy.com/tags/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Java学习资源整理</title>
    <link href="http://litexy.com/2018/08/09/Java%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86/"/>
    <id>http://litexy.com/2018/08/09/Java学习资源整理/</id>
    <published>2018-08-09T12:02:31.000Z</published>
    <updated>2019-01-09T16:19:08.763Z</updated>
    
    <content type="html"><![CDATA[<p>这里整理一些自己平常搜集的比较好的关于Java的学习资源，主要包括博客站点、书籍、课程等。</p><h2 id="了解Java最新资讯"><a href="#了解Java最新资讯" class="headerlink" title="了解Java最新资讯"></a>了解Java最新资讯</h2><p>这部分主要是了解与Java相关的动态以及信息，能够拓展我们的视野以及寻找一些好的idea。每天早晚都可以刷一刷，可以说是每日必逛。下面列出我采取的几种方式。</p><h3 id="1-关注twitter上的Java组织以及大牛"><a href="#1-关注twitter上的Java组织以及大牛" class="headerlink" title="1.关注twitter上的Java组织以及大牛"></a>1.关注twitter上的Java组织以及大牛</h3><p>许多大牛或公司会在twitter上发布有关Java的最新动态及相关资源，多逛逛说不定会有意外收获。下面推荐几个比较好的：</p><a id="more"></a><p><a href="https://twitter.com/java" target="_blank" rel="noopener">@Java的官方账号</a></p><p><a href="https://twitter.com/OracleCodeOne" target="_blank" rel="noopener">@Oracle Code One</a></p><p><a href="https://twitter.com/springcentral" target="_blank" rel="noopener">@SpringCentral</a></p><p>几个Java大牛</p><p><a href="https://twitter.com/springunidotcom" target="_blank" rel="noopener">@Laszlo Csontos</a></p><p><a href="https://twitter.com/BrianGoetz" target="_blank" rel="noopener">@Brian Goetz</a></p><p>具体可以参见下面这篇文章:</p><p><a href="https://www.e4developer.com/2018/04/22/how-to-stay-up-to-date-with-java-and-tech-use-twitter/" target="_blank" rel="noopener">How to stay up to date with Java and Tech? Use Twitter!</a></p><h3 id="2-关注reddit上的Java讯息"><a href="#2-关注reddit上的Java讯息" class="headerlink" title="2.关注reddit上的Java讯息"></a>2.关注reddit上的Java讯息</h3><p>除了twitter，reddit也是一个比较好的平台，可以关注上面的Java，learnjava, javahelp板块。</p><p><img src="1.jpg" style="zoom: 50%"></p><p>具体的可以参考下面这篇文章:</p><p><a href="https://www.e4developer.com/2018/08/05/reddit-the-java-goldmine/" target="_blank" rel="noopener">Reddit – the Java goldmine</a></p><h3 id="3-Hacker-News"><a href="#3-Hacker-News" class="headerlink" title="3.Hacker News"></a>3.Hacker News</h3><p>不仅是Java, 这里也可以浏览关于编程的最新资讯，界面比较简单直接.</p><p><a href="https://news.ycombinator.com/" target="_blank" rel="noopener">https://news.ycombinator.com/</a></p><h3 id="4-Medium"><a href="#4-Medium" class="headerlink" title="4.Medium"></a>4.Medium</h3><p>上面也可以Follow一些大牛，上面的文章质量还比较高，可以适当看看。</p><p><a href="https://medium.com/" target="_blank" rel="noopener">https://medium.com/</a></p><h3 id="5-Quora和知乎"><a href="#5-Quora和知乎" class="headerlink" title="5. Quora和知乎"></a>5. Quora和知乎</h3><h2 id="优秀博客站点"><a href="#优秀博客站点" class="headerlink" title="优秀博客站点"></a>优秀博客站点</h2><p>这里主要分享一些比较好的关于Java的博客，包括相关公司组织的以及个人博客。</p><h3 id="公司组织"><a href="#公司组织" class="headerlink" title="公司组织"></a>公司组织</h3><h4 id="1-阿里中间件博客"><a href="#1-阿里中间件博客" class="headerlink" title="1.阿里中间件博客"></a><a href="http://jm.taobao.org/" target="_blank" rel="noopener">1.阿里中间件博客</a></h4><p>想进阿里的可要关注了，内容涉及的可能比较难，可以拓宽视野以及知道业界在做什么。</p><h4 id="2-IBM-developerWorks中国"><a href="#2-IBM-developerWorks中国" class="headerlink" title="2.IBM developerWorks中国"></a><a href="https://www.ibm.com/developerworks/cn/java/" target="_blank" rel="noopener">2.IBM developerWorks中国</a></h4><p>上面提供了十分丰富和优质的Java学习资源，包括专题以及系列博客，可以重点关注。</p><h4 id="3-美团点评技术博客"><a href="#3-美团点评技术博客" class="headerlink" title="3.美团点评技术博客"></a><a href="https://tech.meituan.com/?l=80&amp;pos=0" target="_blank" rel="noopener">3.美团点评技术博客</a></h4><p>不知Java了，包括了前端、算法、数据库优化等，内容比较优质，大部分都是美团在技术中的应用相关的一些原理和实践，很有启发。</p><h4 id="4-Google开发者中心"><a href="#4-Google开发者中心" class="headerlink" title="4.Google开发者中心"></a><a href="https://developers.google.cn/" target="_blank" rel="noopener">4.Google开发者中心</a></h4><h4 id="5-Oracle官方Java教程"><a href="#5-Oracle官方Java教程" class="headerlink" title="5.Oracle官方Java教程"></a>5.Oracle官方Java教程</h4><p><a href="http://www.oracle.com/technetwork/cn/java/index.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/cn/java/index.html</a><br><a href="https://docs.oracle.com/javase/tutorial/tutorialLearningPaths.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/tutorialLearningPaths.html</a></p><h4 id="6-黑客派"><a href="#6-黑客派" class="headerlink" title="6.黑客派"></a><a href="https://hacpai.com/" target="_blank" rel="noopener">6.黑客派</a></h4><h4 id="7-并发编程网"><a href="#7-并发编程网" class="headerlink" title="7.并发编程网"></a><a href="http://ifeve.com/" target="_blank" rel="noopener">7.并发编程网</a></h4><h4 id="8-Iteye-Java"><a href="#8-Iteye-Java" class="headerlink" title="8.Iteye Java"></a><a href="http://www.iteye.com/" target="_blank" rel="noopener">8.Iteye Java</a></h4><h4 id="9-InfoQ"><a href="#9-InfoQ" class="headerlink" title="9.InfoQ"></a><a href="http://www.infoq.com/cn/" target="_blank" rel="noopener">9.InfoQ</a></h4><h4 id="10-DZone"><a href="#10-DZone" class="headerlink" title="10.DZone"></a><a href="https://dzone.com/" target="_blank" rel="noopener">10.DZone</a></h4><p>应该不止有Java</p><h4 id="11-Stack-Overflow"><a href="#11-Stack-Overflow" class="headerlink" title="11.Stack Overflow"></a><a href="https://stackoverflow.com/" target="_blank" rel="noopener">11.Stack Overflow</a></h4><p>上面的回答真的非常非常专业</p><h3 id="个人博客"><a href="#个人博客" class="headerlink" title="个人博客"></a>个人博客</h3><h4 id="1-E4Developer"><a href="#1-E4Developer" class="headerlink" title="1.E4Developer"></a><a href="https://www.e4developer.com/start-here/" target="_blank" rel="noopener">1.E4Developer</a></h4><p>主要是Java和Spring相关，作者写的文章非常好，还会分享一些观点和Java资料。</p><h4 id="2-baeldung"><a href="#2-baeldung" class="headerlink" title="2.baeldung"></a><a href="https://www.baeldung.com/" target="_blank" rel="noopener">2.baeldung</a></h4><p>Spring非常丰富和高质量教程</p><h4 id="3-Cafe-au-Lait"><a href="#3-Cafe-au-Lait" class="headerlink" title="3.Cafe au Lait"></a><a href="http://www.cafeaulait.org/" target="_blank" rel="noopener">3.Cafe au Lait</a></h4><p>Java网络编程作者，内容丰富。</p><h4 id="4-Java成神之路"><a href="#4-Java成神之路" class="headerlink" title="4.Java成神之路"></a><a href="http://www.hollischuang.com/" target="_blank" rel="noopener">4.Java成神之路</a></h4><h4 id="5-journaldev"><a href="#5-journaldev" class="headerlink" title="5.journaldev"></a><a href="https://www.journaldev.com/" target="_blank" rel="noopener">5.journaldev</a></h4><p>资源丰富，包括Java基础、Servle、Spring、设计模式等。</p><h4 id="6-孤傲苍狼"><a href="#6-孤傲苍狼" class="headerlink" title="6.孤傲苍狼"></a><a href="http://www.cnblogs.com/xdp-gacl/p/3729033.html" target="_blank" rel="noopener">6.孤傲苍狼</a></h4><p>JavaWeb总结，很好的关于JavaWeb的资源</p><h4 id="7-阿里大牛"><a href="#7-阿里大牛" class="headerlink" title="7.阿里大牛"></a><a href="http://wuchong.me/" target="_blank" rel="noopener">7.阿里大牛</a></h4><h4 id="8-ScriptShi"><a href="#8-ScriptShi" class="headerlink" title="8.ScriptShi"></a><a href="https://www.xjtushilei.com/" target="_blank" rel="noopener">8.ScriptShi</a></h4><p>网站界面很好，组织的很好。</p><h2 id="Java书籍"><a href="#Java书籍" class="headerlink" title="Java书籍"></a>Java书籍</h2><p>分享一些暂时知道的比较值得读的Java书籍</p><h3 id="JavaSE相关"><a href="#JavaSE相关" class="headerlink" title="JavaSE相关"></a>JavaSE相关</h3><h4 id="1-《Java编程思想》"><a href="#1-《Java编程思想》" class="headerlink" title="1.《Java编程思想》"></a>1.《Java编程思想》</h4><h4 id="2-《Java核心技术卷一》"><a href="#2-《Java核心技术卷一》" class="headerlink" title="2.《Java核心技术卷一》"></a>2.《Java核心技术卷一》</h4><h4 id="3-《Effective-Java》"><a href="#3-《Effective-Java》" class="headerlink" title="3.《Effective Java》"></a>3.《Effective Java》</h4><h4 id="4-《深入理解Java虚拟机》"><a href="#4-《深入理解Java虚拟机》" class="headerlink" title="4.《深入理解Java虚拟机》"></a>4.《深入理解Java虚拟机》</h4><h4 id="5-《Java8实战》"><a href="#5-《Java8实战》" class="headerlink" title="5.《Java8实战》"></a>5.《Java8实战》</h4><h4 id="6-《Java高并发编程实战》"><a href="#6-《Java高并发编程实战》" class="headerlink" title="6.《Java高并发编程实战》"></a>6.《Java高并发编程实战》</h4><h3 id="Java-Web相关"><a href="#Java-Web相关" class="headerlink" title="Java Web相关"></a>Java Web相关</h3><h4 id="1-《深入分析Java-Web技术内幕》"><a href="#1-《深入分析Java-Web技术内幕》" class="headerlink" title="1.《深入分析Java Web技术内幕》"></a>1.《深入分析Java Web技术内幕》</h4><h4 id="2-《spring实战》"><a href="#2-《spring实战》" class="headerlink" title="2.《spring实战》"></a>2.《spring实战》</h4><h4 id="3-《Head-First-Servlets-amp-JSP》"><a href="#3-《Head-First-Servlets-amp-JSP》" class="headerlink" title="3.《Head First Servlets &amp; JSP》"></a>3.《Head First Servlets &amp; JSP》</h4><h2 id="Github资源"><a href="#Github资源" class="headerlink" title="Github资源"></a>Github资源</h2><p>除了理论之外，实践很关键，这时需要到Github上找一些教程和源码来读一读。首选推荐一款比较好的能对Github上的star进行分类的工具: <a href="https://app.astralapp.com/auth" target="_blank" rel="noopener">Astral</a><br>当star多了后，用这个真的非常方便管理。<br><img src="2.jpg" style="zoom: 50%"></p><h3 id="比较好的教程资源"><a href="#比较好的教程资源" class="headerlink" title="比较好的教程资源"></a>比较好的教程资源</h3><h4 id="1-Awesome-Java"><a href="#1-Awesome-Java" class="headerlink" title="1.Awesome Java"></a><a href="https://github.com/akullpp/awesome-java" target="_blank" rel="noopener">1.Awesome Java</a></h4><h4 id="2-Java-Interview"><a href="#2-Java-Interview" class="headerlink" title="2.Java-Interview"></a><a href="https://github.com/crossoverJie/Java-Interview" target="_blank" rel="noopener">2.Java-Interview</a></h4><p>Java面试题整理</p><h4 id="3-JDK源码阅读笔记"><a href="#3-JDK源码阅读笔记" class="headerlink" title="3.JDK源码阅读笔记"></a><a href="https://github.com/seaswalker/JDK" target="_blank" rel="noopener">3.JDK源码阅读笔记</a></h4><h4 id="4-Java设计模式实现"><a href="#4-Java设计模式实现" class="headerlink" title="4.Java设计模式实现"></a><a href="https://github.com/iluwatar/java-design-patterns" target="_blank" rel="noopener">4.Java设计模式实现</a></h4><h4 id="5-Java学习笔记"><a href="#5-Java学习笔记" class="headerlink" title="5.Java学习笔记"></a><a href="https://github.com/brianway/java-learning" target="_blank" rel="noopener">5.Java学习笔记</a></h4><p>包括JavaSE和JavaWeb</p><h3 id="练手项目"><a href="#练手项目" class="headerlink" title="练手项目"></a>练手项目</h3><h4 id="1-shopping-management-system"><a href="#1-shopping-management-system" class="headerlink" title="1.shopping-management-system"></a><a href="https://github.com/zhanglei-workspace/shopping-management-system" target="_blank" rel="noopener">1.shopping-management-system</a></h4><p>Java购物网站，从使用最开始的JSP/Servlet进行开发，到后面不断加入Spring、MyBatis等框架，一步步循序渐进。</p><h4 id="2-客户管理系统"><a href="#2-客户管理系统" class="headerlink" title="2.客户管理系统"></a><a href="https://github.com/codingXiaxw/CustomerManagement" target="_blank" rel="noopener">2.客户管理系统</a></h4><p>简单的使用MVC的客户管理系统</p><h4 id="3-SSM商品查询"><a href="#3-SSM商品查询" class="headerlink" title="3.SSM商品查询"></a><a href="https://github.com/codingXiaxw/ssm" target="_blank" rel="noopener">3.SSM商品查询</a></h4><p>在上面2的基础上进一步整合SSM进行开发</p><h4 id="4-Java高并发秒杀系统"><a href="#4-Java高并发秒杀系统" class="headerlink" title="4.Java高并发秒杀系统"></a><a href="https://github.com/codingXiaxw/seckill" target="_blank" rel="noopener">4.Java高并发秒杀系统</a></h4><h4 id="5-java-nio-server"><a href="#5-java-nio-server" class="headerlink" title="5.java-nio-server"></a><a href="https://github.com/jjenkov/java-nio-server" target="_blank" rel="noopener">5.java-nio-server</a></h4><h3 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h3><h4 id="1-JDK源码"><a href="#1-JDK源码" class="headerlink" title="1.JDK源码"></a>1.JDK源码</h4><h4 id="2-Spring-Framework"><a href="#2-Spring-Framework" class="headerlink" title="2.Spring Framework"></a><a href="https://github.com/spring-projects/spring-framework" target="_blank" rel="noopener">2.Spring Framework</a></h4><h4 id="3-MyBatis"><a href="#3-MyBatis" class="headerlink" title="3.MyBatis"></a><a href="https://github.com/mybatis/mybatis-3" target="_blank" rel="noopener">3.MyBatis</a></h4><h4 id="4-sparkjava"><a href="#4-sparkjava" class="headerlink" title="4.sparkjava"></a><a href="https://github.com/perwendel/spark/" target="_blank" rel="noopener">4.sparkjava</a></h4><p>一个非常nice的Java Web框架，非常简单就能搭建自己的Web应用。</p><h2 id="课程相关"><a href="#课程相关" class="headerlink" title="课程相关"></a>课程相关</h2><h4 id="1-普林斯顿Alorithms-4th"><a href="#1-普林斯顿Alorithms-4th" class="headerlink" title="1.普林斯顿Alorithms,4th"></a>1.普林斯顿Alorithms,4th</h4><p>使用Java来实现常用算法和数据结构，代码组织的非常好，除了能学到算法知识外，还能从中学到很多Java编程方式。</p><p><a href="https://algs4.cs.princeton.edu/home/" target="_blank" rel="noopener">课程Web站点</a></p><h4 id="2-伯克利cs61b"><a href="#2-伯克利cs61b" class="headerlink" title="2.伯克利cs61b"></a><a href="http://datastructur.es/sp17/index.html" target="_blank" rel="noopener">2.伯克利cs61b</a></h4><p>也是使用Java来实现数据结构和算法，其中有些参考读物也来自上述算法,4th。上面提供了丰富的lab和project，教你一些工程上的实用的东西(IDEA, maven, git等)，虽然比较难，但是学下来编程能力会得到很大提高。</p><h4 id="3-慕课网相关课程"><a href="#3-慕课网相关课程" class="headerlink" title="3.慕课网相关课程"></a>3.慕课网相关课程</h4><p><a href="http://happymmall.com/" target="_blank" rel="noopener">http://happymmall.com/</a></p><h4 id="4-黑马程序员Java就业班及项目"><a href="#4-黑马程序员Java就业班及项目" class="headerlink" title="4.黑马程序员Java就业班及项目"></a>4.黑马程序员Java就业班及项目</h4><h4 id="5-Udemy"><a href="#5-Udemy" class="headerlink" title="5.Udemy"></a>5.<a href="https://www.udemy.com/" target="_blank" rel="noopener">Udemy</a></h4><p>上面的课程资源也丰富，价格相对来说比较便宜，Java和Web开发的课程也不少。<br>下面是关于如何在Udemy上获取优惠的tips:</p><p><a href="https://buzzorange.com/techorange/2017/09/07/how-to-purchase-udemy-within-300-dollers/" target="_blank" rel="noopener">https://buzzorange.com/techorange/2017/09/07/how-to-purchase-udemy-within-300-dollers/</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>资源很多，自己还是要脚踏实地去看一本书，读一些源码，多思考，多总结。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里整理一些自己平常搜集的比较好的关于Java的学习资源，主要包括博客站点、书籍、课程等。&lt;/p&gt;
&lt;h2 id=&quot;了解Java最新资讯&quot;&gt;&lt;a href=&quot;#了解Java最新资讯&quot; class=&quot;headerlink&quot; title=&quot;了解Java最新资讯&quot;&gt;&lt;/a&gt;了解Java最新资讯&lt;/h2&gt;&lt;p&gt;这部分主要是了解与Java相关的动态以及信息，能够拓展我们的视野以及寻找一些好的idea。每天早晚都可以刷一刷，可以说是每日必逛。下面列出我采取的几种方式。&lt;/p&gt;
&lt;h3 id=&quot;1-关注twitter上的Java组织以及大牛&quot;&gt;&lt;a href=&quot;#1-关注twitter上的Java组织以及大牛&quot; class=&quot;headerlink&quot; title=&quot;1.关注twitter上的Java组织以及大牛&quot;&gt;&lt;/a&gt;1.关注twitter上的Java组织以及大牛&lt;/h3&gt;&lt;p&gt;许多大牛或公司会在twitter上发布有关Java的最新动态及相关资源，多逛逛说不定会有意外收获。下面推荐几个比较好的：&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://litexy.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://litexy.com/tags/Java/"/>
    
      <category term="资源" scheme="http://litexy.com/tags/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客绑定域名以及增加gitment评论</title>
    <link href="http://litexy.com/2018/08/02/hexo%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D%E4%BB%A5%E5%8F%8A%E5%A2%9E%E5%8A%A0gitment%E8%AF%84%E8%AE%BA/"/>
    <id>http://litexy.com/2018/08/02/hexo博客绑定域名以及增加gitment评论/</id>
    <published>2018-08-02T08:34:50.000Z</published>
    <updated>2018-12-12T16:01:25.248Z</updated>
    
    <content type="html"><![CDATA[<p>最近在NameSilo上注册了个域名，并将hexo博客同时部署到Github Page和Coding Page中以及绑定域名，在其中遇到了一些问题，将整个过程记录下来供后续参考。</p><h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h2><p>首先需要购买一个域名，国内可以在万网上购买，但是需要备案比较麻烦。这里有几个不错的域名购买网站，不需要备案。</p><p><a href="https://www.namesilo.com/index.php" target="_blank" rel="noopener">namesilo</a></p><a id="more"></a><p><a href="https://sg.godaddy.com/zh?isc=gocacnsl01" target="_blank" rel="noopener">godaddy</a></p><p><a href="https://www.namecheap.com/" target="_blank" rel="noopener">namecheap</a></p><p>namecheap好像不支持支付宝，godaddy又比较坑（第一年域名很便宜，后面会涨价），只有namesilo价格还行，而且支持支付宝。具体域名购买建议可以参见知乎上的帖子：<a href="https://www.zhihu.com/question/19551906" target="_blank" rel="noopener">https://www.zhihu.com/question/19551906</a></p><p>这里我买的.com域名，一年大概50多左右。买好后可以看到Account Domains下多了一个域名：</p><p><img src="1.jpg" type="zoom: 50%"></p><h2 id="将博客同时部署至Github和Coding"><a href="#将博客同时部署至Github和Coding" class="headerlink" title="将博客同时部署至Github和Coding"></a>将博客同时部署至Github和Coding</h2><p>Coding是国内的一个代码托管网站，考虑GitHub国内访问慢，所以这里将博客也部署至Coding。</p><h3 id="创建coding仓库"><a href="#创建coding仓库" class="headerlink" title="创建coding仓库"></a>创建coding仓库</h3><p>和GitHub类似，也需要新建一个和用户名一致的仓库名，如litexiny，这样才能通过litexiny.coding.me访问（GitHub是litexiny.github.io）。</p><p><img src="2.jpg" style="zoom: 50%"></p><p>由于需要绑定自己的域名，所以需要进入项目页面的Pages服务中开启Coding Pages服务，并绑定域名，绑定成功后如下图所示：</p><p><img src="3" style="zoom: 50%"></p><h3 id="修改-config-yml文件"><a href="#修改-config-yml文件" class="headerlink" title="修改_config.yml文件"></a>修改_config.yml文件</h3><p>在博客根目录下找到_config.yml文件，编辑deploy选项，将coding地址也加入进来，修改为：</p><p><img src="4.jpg" style="zoom: 60%"></p><p>此时通过命令<code>hexo g</code>和<code>hexo d</code>就可将文章同时发布到GitHub和Coding上了。</p><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>域名解析可以使用namesilo自己提供的，也可以使用dnspos来解析，我这里使用dnspos进行解析。现在要实现国内走coding，海外走github，需要添加几条CNAME指向这两个域名，将github设置为国外的，coding设置为默认，如图所示：</p><p><img src="5.jpg" style="zoom: 60%"></p><p>注意后面有个点<code>.</code><br>Coding由于在前面开启pages服务的时候就绑定了域名，现在就可以直接访问了。<br>而Github还需要上传一个CNAME文件到静态网页的根目录才行，我们可以把这个文件放在<code>Hexo\source</code>文件夹下面，deploy的时候会自动帮你上传到网站根目录。CNAME文件里只需要放你想绑定的域名就可以了。（注意：CNAME文件是没有后缀的）</p><p>最后还需要在namesilo中添加DNSPOS的NameServer，如下图所示：</p><p><img src="6.jpg" style="zoom: 60%"></p><p>至此，通过自己的域名就可以访问博客了。</p><h2 id="添加gitment评论"><a href="#添加gitment评论" class="headerlink" title="添加gitment评论"></a>添加gitment评论</h2><p>gitment就是将评论放到博客github仓库的issue里，而且支持markdown，比较适合程序员。</p><h3 id="注册OAuth-Application"><a href="#注册OAuth-Application" class="headerlink" title="注册OAuth Application"></a>注册OAuth Application</h3><p>首先在<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">https://github.com/settings/applications/new</a>上进行注册，如图：</p><p><img src="7.jpg" style="zoom: 60%"></p><p>注意上述Application name最好填自己绑定的域名（不加http等前缀的），HomePage URL和Authorization callback URL都填自己绑定域名后的博客地址（如这里就不能填name.github.io）</p><h3 id="修改主题下的-config-yml配置"><a href="#修改主题下的-config-yml配置" class="headerlink" title="修改主题下的_config.yml配置"></a>修改主题下的_config.yml配置</h3><p>上述填完注册好了会生成Client ID和Client Secret，将其放到gitment中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#5、Gitment</span><br><span class="line">gitment_owner: xinyuexy      #你的 GitHub ID</span><br><span class="line">gitment_repo: &apos;xinyuexy.github.io&apos;          #存储评论的 repo</span><br><span class="line">gitment_oauth:</span><br><span class="line">  client_id: &apos;yourid&apos;           #client ID</span><br><span class="line">  client_secret: &apos;yoursecret&apos;       #client secret</span><br></pre></td></tr></table></figure><p>注意gitment_repo要填GitHub的博客地址（不能是自己域名的，因为将评论放到GitHub的issue中）</p><h3 id="初始化评论"><a href="#初始化评论" class="headerlink" title="初始化评论"></a>初始化评论</h3><p>这时查看文章下的评论，会出现Error: Comments Not Initialized的错误，只需要在该页面的Gitment评论区登陆GitHub账号，并点击Initialize Comments（每篇文章下都要初始化后才能使用）:</p><p><img src="8.jpg" style="zoom: 60%"></p><p>初始化后如下：</p><p><img src="9.jpg" style="zoom: 60%"></p><p>可以看到issue page已经有刚才的评论了：</p><p><img src="10.jpg" style="zoom: 60%"></p><h2 id="总结与感想"><a href="#总结与感想" class="headerlink" title="总结与感想"></a>总结与感想</h2><p>（1）遇到问题首先要思考为什么，然后要多尝试不同组合的可能解决方案。</p><p>（2）不能安于现状，要多打磨，让自己的东西变得更完美。</p><p>参考资料：</p><p>绑定域名相关：</p><p><a href="https://github.com/niices/blog/issues/7" target="_blank" rel="noopener">https://github.com/niices/blog/issues/7</a></p><p><a href="http://flamepeak.com/2016/09/02/NameSilo-gong-lue-20160902/" target="_blank" rel="noopener">http://flamepeak.com/2016/09/02/NameSilo-gong-lue-20160902/</a></p><p>gitment踩坑:</p><p><a href="https://www.jianshu.com/p/57afa4844aaa" target="_blank" rel="noopener">https://www.jianshu.com/p/57afa4844aaa</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在NameSilo上注册了个域名，并将hexo博客同时部署到Github Page和Coding Page中以及绑定域名，在其中遇到了一些问题，将整个过程记录下来供后续参考。&lt;/p&gt;
&lt;h2 id=&quot;购买域名&quot;&gt;&lt;a href=&quot;#购买域名&quot; class=&quot;headerlink&quot; title=&quot;购买域名&quot;&gt;&lt;/a&gt;购买域名&lt;/h2&gt;&lt;p&gt;首先需要购买一个域名，国内可以在万网上购买，但是需要备案比较麻烦。这里有几个不错的域名购买网站，不需要备案。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.namesilo.com/index.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;namesilo&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://litexy.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://litexy.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="hexo" scheme="http://litexy.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode中链表转置问题总结</title>
    <link href="http://litexy.com/2018/08/02/LeetCode%E4%B8%AD%E9%93%BE%E8%A1%A8%E8%BD%AC%E7%BD%AE%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://litexy.com/2018/08/02/LeetCode中链表转置问题总结/</id>
    <published>2018-08-02T02:24:11.000Z</published>
    <updated>2018-08-02T06:29:11.247Z</updated>
    
    <content type="html"><![CDATA[<p>链表转置是很常见的一类链表题目，最近在刷LeetCode题目时，发现链表转置还有这么多的变形，在这里对LeetCode中链表转置的题目进行一下总结。</p><h2 id="转置整个链表"><a href="#转置整个链表" class="headerlink" title="转置整个链表"></a>转置整个链表</h2><p><a href="https://leetcode.com/problems/reverse-linked-list/description/" target="_blank" rel="noopener">LeetCode 206</a></p><p>Reverse a singly linked list.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><a id="more"></a><p>这道题是链表转置最一般的情况了，需要转置整个单链表。最常见的迭代解法是设置一个prev指针，依次将每个结点的next指针指向prev，遍历的过程中需要提取保存next指针，prev指针也不断向后变化，最后返回prev，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = head.next;</span><br><span class="line">        head.next = prev;</span><br><span class="line">        prev = head;</span><br><span class="line">        head = next;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> prev;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>最后返回的prev指针指向的是转置后链表的头结点。当然，这题也可以用递归解法来做，这里不再具体阐述。</p><h2 id="转置区间链表"><a href="#转置区间链表" class="headerlink" title="转置区间链表"></a>转置区间链表</h2><p><a href="https://leetcode.com/problems/reverse-linked-list-ii/description/" target="_blank" rel="noopener">LeetCode 92</a></p><p>Reverse a linked list from position <em>m</em> to <em>n</em>. Do it in one-pass.</p><p><strong>Note: </strong>1 ≤ <em>m</em> ≤ <em>n</em> ≤ length of list.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4</span><br><span class="line">Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure><p>这道题和上道题有些差别，可以说上道题是这道题的特殊情况，只不过把m=1，n=链表的长度，从这道题我们将总结链表转置的一般性解法。这道题转置区间链表需要保存开始反转位置的前一个结点（即m-1），反转的最后一个结点n，以及其下一个结点n+1。因为在反转结束后，需要将m-1的next指针指向反转后的头结点，将反转后的尾结点的next指向n+1。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>如果使用上道题的解法，需要稍微变换一下，增加一个结束结点参数，相应代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode start, ListNode end)</span> </span>&#123;</span><br><span class="line">     ListNode prev = end;</span><br><span class="line">     <span class="keyword">while</span>(start != end) &#123;</span><br><span class="line">         ListNode next = start.next;</span><br><span class="line">         start.next = prev;</span><br><span class="line">         prev = start;</span><br><span class="line">         start = next;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> prev;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上述start为开始反转的结点，end为反转结束结点的下一个结点。上述函数返回的是反转后的头结点，还需要获得其尾结点，其实仔细观察就可以发现传入的start参数(即反转开始结点)在转置后就指向了反转后的尾结点。这道题的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || m == n) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        ListNode end = dummy.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; m-<span class="number">1</span>) &#123;</span><br><span class="line">        pre = pre.next;<span class="comment">//find m-1 node</span></span><br><span class="line">        &#125;</span><br><span class="line">        end = end.next;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        ListNode start = pre.next;</span><br><span class="line">        ListNode revHead = reverse(start, end);</span><br><span class="line">        pre.next = revHead;</span><br><span class="line">        start.next = end;<span class="comment">//start为转置后的尾结点，将其指向下一个结点</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>针对这道题，链表转置还有另一种方法，首先设置一个虚拟结点指向head（因为可能要改变头结点），对要转置的每一个结点，依次遍历将其放到最前面。相应代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode pre, ListNode next)</span> </span>&#123;</span><br><span class="line">   ListNode last = pre.next;</span><br><span class="line">   ListNode cur = last.next;</span><br><span class="line">   <span class="keyword">while</span>(cur != next) &#123;</span><br><span class="line">   last.next = cur.next;</span><br><span class="line">   cur.next = pre.next;</span><br><span class="line">   pre.next = cur;</span><br><span class="line">   cur = last.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>prev为要转置的结点的前一个结点，next指向转置区间最后一个结点的下一个结点。每次将结点放到前面（将prev指针指向该结点），最终返回的结点指向的是转置后的最后一个结点，这样就不需要找最后一个结点了。使用该方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (head == <span class="keyword">null</span> || m == n) &#123;</span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">       dummy.next = head;</span><br><span class="line">       ListNode pre = dummy;</span><br><span class="line">       ListNode end = dummy.next;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">       <span class="keyword">if</span> (i &lt; m-<span class="number">1</span>) &#123;</span><br><span class="line">       pre = pre.next;<span class="comment">//find m-1 node</span></span><br><span class="line">       &#125;</span><br><span class="line">       end = end.next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ListNode last = reverse(pre, end);</span><br><span class="line">       last.next = end;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> dummy.next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>上述代码在转置的过程中就已经将pre指向链表的头结点了，只需要将返回的last指向下一个 结点就行了。</p><h2 id="分组转置链表"><a href="#分组转置链表" class="headerlink" title="分组转置链表"></a>分组转置链表</h2><p><a href="https://leetcode.com/problems/reverse-nodes-in-k-group/description/" target="_blank" rel="noopener">LeetCode 25</a></p><p>Given a linked list, reverse the nodes of a linked list <em>k</em> at a time and return its modified list.</p><p><em>k</em> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of <em>k</em> then left-out nodes in the end should remain as it is.</p><p><strong>Example:</strong></p><p>Given this linked list: <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p><p>For <em>k</em> = 2, you should return: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p><p>For <em>k</em> = 3, you should return: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p><p><strong>Note:</strong></p><ul><li>Only constant extra memory is allowed.</li><li>You may not alter the values in the list’s nodes, only nodes itself may be changed.</li></ul><p>这道题应该是链表转置中比较难的了，要求每k个元素进行转置，其实也是上面区间转置的变形，只不过这个区间长度固定为k，并且有多个区间。这道题可以借用上道题的第二种方法，首先设置虚拟节点指向head，找到下一个分组的最后一个节点的next，每次转置后返回的是这一分组的最后一个节点（即下一个分组的前一个节点），相应代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || k == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    ListNode pre = dummy;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">if</span> (i % k == <span class="number">0</span>) &#123;</span><br><span class="line">    pre = reverse(pre, head.next);</span><br><span class="line">    head = pre.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode pre, ListNode next)</span> </span>&#123;</span><br><span class="line">ListNode last = pre.next;</span><br><span class="line">ListNode cur = last.next;</span><br><span class="line"><span class="keyword">while</span>(cur != next) &#123;</span><br><span class="line">last.next = cur.next;</span><br><span class="line">cur.next = pre.next;</span><br><span class="line">pre.next = cur;</span><br><span class="line">cur = last.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* an example:</span><br><span class="line">* a linked list:</span><br><span class="line">* 0-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6</span><br><span class="line">* |           |   </span><br><span class="line">* pre        next</span><br><span class="line">* after call pre = reverse(pre, next)</span><br><span class="line">* </span><br><span class="line">* 0-&gt;3-&gt;2-&gt;1-&gt;4-&gt;5-&gt;6</span><br><span class="line">*          |  |</span><br><span class="line">*          pre next</span><br></pre></td></tr></table></figure><h2 id="总结与感想"><a href="#总结与感想" class="headerlink" title="总结与感想"></a>总结与感想</h2><p>（1）链表涉及到头结点改变的，往往需要新建一个dummy结点指向原来的头结点，这样就算头结点变动了，我们还可以通过dummy-&gt;next来获得新链表的头结点。</p><p>（2）对链表问题要多在纸上画图，模拟过程，用不同的方法，总结这些方法的共性。</p><p>参考资料：</p><p><a href="http://www.cnblogs.com/grandyang/p/4306611.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/4306611.html</a></p><p><a href="https://www.cnblogs.com/lichen782/p/leetcode_Reverse_Nodes_in_kGroup.html" target="_blank" rel="noopener">https://www.cnblogs.com/lichen782/p/leetcode_Reverse_Nodes_in_kGroup.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链表转置是很常见的一类链表题目，最近在刷LeetCode题目时，发现链表转置还有这么多的变形，在这里对LeetCode中链表转置的题目进行一下总结。&lt;/p&gt;
&lt;h2 id=&quot;转置整个链表&quot;&gt;&lt;a href=&quot;#转置整个链表&quot; class=&quot;headerlink&quot; title=&quot;转置整个链表&quot;&gt;&lt;/a&gt;转置整个链表&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/reverse-linked-list/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode 206&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Reverse a singly linked list.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://litexy.com/categories/Algorithm/"/>
    
    
      <category term="LinkedList" scheme="http://litexy.com/tags/LinkedList/"/>
    
      <category term="Algorithm" scheme="http://litexy.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Java中的Iterable与Iterator详解</title>
    <link href="http://litexy.com/2018/07/09/Java%E4%B8%AD%E7%9A%84Iterable%E4%B8%8EIterator%E8%BE%A8%E6%9E%90/"/>
    <id>http://litexy.com/2018/07/09/Java中的Iterable与Iterator辨析/</id>
    <published>2018-07-09T12:02:31.000Z</published>
    <updated>2018-07-09T13:34:42.216Z</updated>
    
    <content type="html"><![CDATA[<p>在Java中，我们可以对List集合进行如下几种方式的遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">5</span>);</span><br><span class="line">list.add(<span class="number">23</span>);</span><br><span class="line">list.add(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    System.out.print(list.get(i) + <span class="string">","</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Iterator it = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    System.out.print(it.next() + <span class="string">","</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">    System.out.print(i + <span class="string">","</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种就是普通的for循环，第二种为迭代器遍历，第三种是for each循环。后面两种方式涉及到Java中的iterator和iterable对象，接下来我们来看看这两个对象的区别以及如何在自定义类中实现for each循环。</p><a id="more"></a><h2 id="Iterator与Iterable"><a href="#Iterator与Iterable" class="headerlink" title="Iterator与Iterable"></a>Iterator与Iterable</h2><p>iterator为Java中的迭代器对象，是能够对List这样的集合进行迭代遍历的底层依赖。而iterable接口里定义了返回iterator的方法，相当于对iterator的封装，同时实现了iterable接口的类可以支持for each循环。</p><h3 id="iterator内部细节"><a href="#iterator内部细节" class="headerlink" title="iterator内部细节"></a>iterator内部细节</h3><p>jdk中Iterator接口主要方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>iterator通过以上两个方法定义了对集合迭代访问的方法，而具体的实现方式依赖于不同的实现类，具体的集合类实现Iterator接口中的方法以实现迭代。</p><p>可以发现，在List中并没有实现Iterator接口，而是实现的Iterable接口。进一步观察Iterable接口的源码可以发现其只是返回了一个Iterator对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们可以使用如下方式来对List进行迭代了（通过调用iterator()方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    System.out.print(it.next() + <span class="string">","</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时实现了Iterable接口的还可以使用for each循环。</p><h3 id="for-each原理"><a href="#for-each原理" class="headerlink" title="for each原理"></a>for each原理</h3><p>其实for each循环内部也是依赖于Iterator迭代器，只不过Java提供的语法糖，Java编译器会将其转化为Iterator迭代器方式遍历。我们对以下for each循环进行反编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">      System.out.println(i);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>反编译后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer i;</span><br><span class="line"><span class="keyword">for</span>(Iterator iterator = list.iterator(); iterator.hasNext(); System.out.println(i))&#123;</span><br><span class="line">        i = (Integer)iterator.next();        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到Java的for each增强循环是通过iterator迭代器方式实现的。</p><h3 id="深入探讨Iterable与Iterator关系"><a href="#深入探讨Iterable与Iterator关系" class="headerlink" title="深入探讨Iterable与Iterator关系"></a>深入探讨Iterable与Iterator关系</h3><p>有一个问题，为什么不直接将hasNext()，next()方法放在Iterable接口中，其他类直接实现就可以了？</p><p>原因是有些集合类可能不止一种遍历方式，实现了Iterable的类可以再实现多个Iterator内部类，例如<code>LinkedList</code>中的<code>ListItr</code>和<code>DescendingIterator</code>两个内部类，就分别实现了双向遍历和逆序遍历。通过返回不同的<code>Iterator</code>实现不同的遍历方式，这样更加灵活。如果把两个接口合并，就没法返回不同的<code>Iterator</code>实现类了。ListItr相关源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">      checkPositionIndex(index);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItr</span> <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">...</span><br><span class="line">      ListItr(<span class="keyword">int</span> index) &#123;</span><br><span class="line">          <span class="comment">// assert isPositionIndex(index);</span></span><br><span class="line">          next = (index == size) ? <span class="keyword">null</span> : node(index);</span><br><span class="line">          nextIndex = index;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> nextIndex &lt; size;</span><br><span class="line">      &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>如上所示可以通过调用<code>list.listIterator()</code>方法返回iterator迭代器（<code>list.iterator()</code>只是其默认实现）</p><p><code>DescendingIterator</code>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DescendingIterator();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DescendingIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ListItr itr = <span class="keyword">new</span> ListItr(size());</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> itr.hasPrevious();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> itr.previous();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        itr.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样可以通过<code>list.descendingIterator()</code>使用该迭代器。</p><h2 id="实现自己的迭代器"><a href="#实现自己的迭代器" class="headerlink" title="实现自己的迭代器"></a>实现自己的迭代器</h2><p>我们现在有一个自定义类ArrayMap，现在如果对其进行如下for each遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayMap&lt;String, Integer&gt; am = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line">am.put(<span class="string">"hello"</span>, <span class="number">5</span>);</span><br><span class="line">am.put(<span class="string">"syrups"</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String s: am) &#123;</span><br><span class="line">   System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们并没有实现hashNext和next抽象方法，所以无法对其进行遍历。</p><h3 id="自定义迭代器类"><a href="#自定义迭代器类" class="headerlink" title="自定义迭代器类"></a>自定义迭代器类</h3><p>我们首先自定义一个迭代器类实现hashNext和next方法，并将其作为ArrayMap的内部类，相关代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> ptr;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">KeyIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         ptr = <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> (ptr != size);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> K <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         K returnItem = keys[ptr];</span><br><span class="line">         ptr += <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">return</span> returnItem;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>可以看到我们在next中指定的遍历规则是根据ArrayMap的key值进行遍历。有了上述迭代器类，我们就可以使用iterator方式在外部对其进行遍历了，遍历代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayMap&lt;String, Integer&gt; am = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line">am.put(<span class="string">"hello"</span>, <span class="number">5</span>);</span><br><span class="line">am.put(<span class="string">"syrups"</span>, <span class="number">10</span>);</span><br><span class="line">ArrayMap.KeyIterator ami = am.new KeyIterator();</span><br><span class="line"><span class="keyword">while</span> (ami.hasNext()) &#123;</span><br><span class="line">    System.out.println(ami.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，通过创建KeyIterator对象进行迭代访问（注意外部类创建内部类对象的方式）。</p><h3 id="支持for-each循环"><a href="#支持for-each循环" class="headerlink" title="支持for each循环"></a>支持for each循环</h3><p>现在还不能支持for each循环访问，因为我们还没有实现iterable接口，首先在ArrayMap中实现Iterable接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> K[] keys;</span><br><span class="line">    <span class="keyword">private</span> V[] values;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        keys = (K[]) <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">        values = (V[]) <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后重写iterator()方法，并在其中返回我们自己的迭代器对象(iterator)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意我们自定义的KeyIterator类必须要实现Iterator接口，否则在iterator()方法中返回的类型不匹配。</p><h2 id="总结与感想"><a href="#总结与感想" class="headerlink" title="总结与感想"></a>总结与感想</h2><p>（1）学会深入思考，一点点抽丝剥茧，多想想为什么这样实现，很多问题没有自己想象中的那么复杂。</p><p>（2）遇到疑惑不放弃，这是提升自己最好的机会，遇到某个疑难的点，解决的过程中会挖掘出很多相关东西。</p><p>参考资料：</p><p>（1）<a href="https://joshhug.gitbooks.io/hug61b/content/chap6/chap63.html" target="_blank" rel="noopener">CS61B</a></p><p>（2）<a href="http://www.hollischuang.com/archives/1776" target="_blank" rel="noopener">for each实现原理</a></p><p>（3）<a href="https://www.jianshu.com/p/cf82ab7e51ef" target="_blank" rel="noopener">Iterable与iterator区别</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Java中，我们可以对List集合进行如下几种方式的遍历：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;List&amp;lt;Integer&amp;gt; list = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;list.add(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;list.add(&lt;span class=&quot;number&quot;&gt;23&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;list.add(&lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; list.size(); i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.print(list.get(i) + &lt;span class=&quot;string&quot;&gt;&quot;,&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Iterator it = list.iterator();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (it.hasNext()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.print(it.next() + &lt;span class=&quot;string&quot;&gt;&quot;,&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (Integer i : list) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.print(i + &lt;span class=&quot;string&quot;&gt;&quot;,&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第一种就是普通的for循环，第二种为迭代器遍历，第三种是for each循环。后面两种方式涉及到Java中的iterator和iterable对象，接下来我们来看看这两个对象的区别以及如何在自定义类中实现for each循环。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://litexy.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://litexy.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="迭代器" scheme="http://litexy.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>关于链表中哨兵结点的问题</title>
    <link href="http://litexy.com/2018/07/06/%E5%85%B3%E4%BA%8E%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%93%A8%E5%85%B5%E7%BB%93%E7%82%B9%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://litexy.com/2018/07/06/关于链表中哨兵结点的问题/</id>
    <published>2018-07-06T08:54:09.000Z</published>
    <updated>2019-01-09T15:52:38.261Z</updated>
    
    <content type="html"><![CDATA[<p>最近正在学习UC Berkeley的CS61B这门课，主要是采用Java语言去实现一些数据结构以及运用数据结构去做一些project。这门课不仅告诉你这个东西怎么做，而且一步一步探寻为什么要这样做以及为什么会有这些功能。我们有时在接触某段代码或功能的实现时，可能直接就看到了它最终的面貌，而不知道如何一步步演化而来，其实每一个功能的添加或优化都是对应一个问题的解决。下面就这门课中关于链表中哨兵结点的相关问题进行总结。</p><h2 id="什么是哨兵结点"><a href="#什么是哨兵结点" class="headerlink" title="什么是哨兵结点"></a>什么是哨兵结点</h2><p>哨兵顾名思义有巡逻、检查的功能，在我们程序中通过增加哨兵结点往往能够简化边界条件，从而防止对特殊条件的判断，使代码更为简便优雅，在链表中应用最为典型。</p><a id="more"></a><h2 id="单链表中的哨兵结点"><a href="#单链表中的哨兵结点" class="headerlink" title="单链表中的哨兵结点"></a>单链表中的哨兵结点</h2><p>首先讨论哨兵结点在单链表中的运用，如果不加哨兵结点在进行头尾删除和插入时需要进行特殊判断。比如在尾部插入结点的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addLast</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">    first = <span class="keyword">new</span> Node(x, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node p = first;</span><br><span class="line">    <span class="keyword">while</span> (p.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    p.next = <span class="keyword">new</span> Node(x, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示需要对结点为空的特殊情况进行判断，头部加了一个哨兵结点后就可以不需要判断了（不会为空）</p><p><img src="./LinkedList1.jpg" style="zoom: 80%"></p><h2 id="双链表中的哨兵结点"><a href="#双链表中的哨兵结点" class="headerlink" title="双链表中的哨兵结点"></a>双链表中的哨兵结点</h2><h3 id="Version-1-双哨兵"><a href="#Version-1-双哨兵" class="headerlink" title="Version 1: 双哨兵"></a>Version 1: 双哨兵</h3><p>在双链表中需要能够在头部和尾部分别进行插入删除操作（可以实现双端队列），为了能快速在尾部进行插入删除，需要引入指向尾部的指针。截图如下（图片来自CS61B）</p><p><img src="./LinkedList2.jpg" style="zoom: 60%"></p><p><img src="./LinkedList3.jpg" style="zoom: 60%"></p><p>上述增加了一个指向尾部的last结点，从上图可以看出一个问题，last结点有时指向哨兵结点，有时指向实际结点。这会导致特殊情况的出现，比如在进行addFirst操作时，last指向哨兵结点时插入后需要将last往后移动一个，而第二张图指向实际结点时在头部插入结点后并不需要改变last指针。这时需要在尾部后也引入一个哨兵结点，以使其一致。相应示意图如下：</p><p><img src="./LinkedList4.jpg" style="zoom: 60%"></p><p><img src="./LinkedList5.jpg" style="zoom: 60%"></p><h3 id="Version-2：循环双链表"><a href="#Version-2：循环双链表" class="headerlink" title="Version 2：循环双链表"></a>Version 2：循环双链表</h3><p>上述Version1需要两个哨兵结点，可以对其进行改进。可以使用头部结点的prev指针指向尾部，尾部结点的next指针指向哨兵，这样就只需要一个哨兵结点，使链表变成循环链表，比Version1更为简洁优雅。</p><p><img src="./LinkedList6.jpg" style="zoom:60%"></p><p><img src="./LinkedList7.jpg" style="zoom:60%"></p><p>在对如上所示进行插入和删除操作时一定要格外注意，自己在写的时候很容易就漏掉某个指针的关系设置，最好在纸上自己画一遍。（对于要改变的连接可能会影响其他的，这时可将其暂存或最好设置）</p><p>在头部插入的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">     Node node = <span class="keyword">new</span> Node(item);</span><br><span class="line">     node.prev = sentinel;</span><br><span class="line">     node.next = sentinel.next;</span><br><span class="line">     sentinel.next.prev = node;</span><br><span class="line">     sentinel.next = node;</span><br><span class="line">     size++;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>尾部插入代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(item);</span><br><span class="line">    node.prev = sentinel.prev;</span><br><span class="line">    node.next = sentinel;</span><br><span class="line">    sentinel.prev.next = node;</span><br><span class="line">    sentinel.prev = node;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>头部删除代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Item <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Item item = sentinel.next.item;</span><br><span class="line">     sentinel.next = sentinel.next.next;</span><br><span class="line">     sentinel.next.prev = sentinel;</span><br><span class="line">     size--;</span><br><span class="line">     <span class="keyword">return</span> item;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>尾部删除代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Item <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Item item = sentinel.prev.item;</span><br><span class="line">    Node sl = sentinel.prev.prev;</span><br><span class="line">    sl.next = sl.next.next;</span><br><span class="line">    sl.next.prev = sl;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结与感想"><a href="#总结与感想" class="headerlink" title="总结与感想"></a>总结与感想</h2><p>（1）虽然看起来很小很简单的事情，但实现起来却有很多细小问题可以考虑，学会把一件小事做的很漂亮。（small but smart）</p><p>（2）学会分析一个东西的来龙去脉，为什么会有这部分，以及怎么改进的。</p><p>参考：</p><p>1.cs61b:<a href="https://joshhug.gitbooks.io/hug61b/content/chap2/chap23.html" target="_blank" rel="noopener">https://joshhug.gitbooks.io/hug61b/content/chap2/chap23.html</a></p><p>2.算法导论10.2链表</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近正在学习UC Berkeley的CS61B这门课，主要是采用Java语言去实现一些数据结构以及运用数据结构去做一些project。这门课不仅告诉你这个东西怎么做，而且一步一步探寻为什么要这样做以及为什么会有这些功能。我们有时在接触某段代码或功能的实现时，可能直接就看到了它最终的面貌，而不知道如何一步步演化而来，其实每一个功能的添加或优化都是对应一个问题的解决。下面就这门课中关于链表中哨兵结点的相关问题进行总结。&lt;/p&gt;
&lt;h2 id=&quot;什么是哨兵结点&quot;&gt;&lt;a href=&quot;#什么是哨兵结点&quot; class=&quot;headerlink&quot; title=&quot;什么是哨兵结点&quot;&gt;&lt;/a&gt;什么是哨兵结点&lt;/h2&gt;&lt;p&gt;哨兵顾名思义有巡逻、检查的功能，在我们程序中通过增加哨兵结点往往能够简化边界条件，从而防止对特殊条件的判断，使代码更为简便优雅，在链表中应用最为典型。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://litexy.com/categories/Algorithm/"/>
    
    
      <category term="LinkedList" scheme="http://litexy.com/tags/LinkedList/"/>
    
      <category term="Algorithm" scheme="http://litexy.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>关于Java中读取和修改SQL大文件的问题</title>
    <link href="http://litexy.com/2018/03/26/%E5%85%B3%E4%BA%8EJava%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%92%8C%E4%BF%AE%E6%94%B9%E5%A4%A7%E6%96%87%E4%BB%B6%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://litexy.com/2018/03/26/关于Java中读取和修改大文件的问题/</id>
    <published>2018-03-26T00:39:59.000Z</published>
    <updated>2019-02-02T03:28:27.003Z</updated>
    
    <content type="html"><![CDATA[<p>最近在项目中需要读取sql文件，并修改里面的一部分内容。主要问题是sql文件里的插入语句中的日期是Oracle形式的，需要将其替换为Mysql形式的，其他的不变。项目中的sql文件有几十万条记录，数据量比较大，这可能在读取文件的时候带来一些问题。</p><p><img src="./01.png" style="zoom:60%"></p><p>如上图所示，由于MySQL中没有to_date函数，而且里面的日期格式不对，也就是需要将画红线的部分替换为’2014-06-25’。（注意一行中有多个to_date）</p><a id="more"></a><h2 id="使用正则表达式进行查找替换"><a href="#使用正则表达式进行查找替换" class="headerlink" title="使用正则表达式进行查找替换"></a>使用正则表达式进行查找替换</h2><p>最直接想到就是使用Java中的正则表达式来匹配到相应的字符串并替换。这里可以先对少量几行的数据进行测试，如果成功了再考虑对整个文件进行替换。</p><p>Java中的正则表达式主要是两个类：Pattern类和Matcher类。Pattern类将正则表达式字符串编译为pattern对象以调用相应的匹配方法。Matcher类是对输入字符串进行解释和匹配操作的引擎。一个典型的使用正则表达式的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pattern p = Pattern.compile(<span class="string">"a*b"</span>);</span><br><span class="line">Matcher m = p.matcher(<span class="string">"aaaaab"</span>);</span><br><span class="line"><span class="keyword">boolean</span> b = m.matches();</span><br></pre></td></tr></table></figure><p>matches()对整个字符串进行匹配,只有整个字符串都匹配了才返回true ，这显然和我们的要求不符，Matcher类中还提供了一个find方法可以进行多次匹配。如果在文本中多次匹配，find() 方法返回第一个，之后每次调用 find() 都会返回下一个，而且可以调用start()和end()方法返回匹配到的字符串在整个字符串中的下标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String patternString = <span class="string">"to_date.&#123;2&#125;\\d&#123;2&#125;-\\d&#123;2&#125;-\\d&#123;4&#125;.\\d&#123;2&#125;:\\d&#123;2&#125;:\\d&#123;2&#125;.&#123;27&#125;"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(patternString)</span><br><span class="line">Matcher matcher = pattern.matcher(line);</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(matcher.find()) &#123; </span><br><span class="line">  String findStr = line.substring(matcher.start(), matcher.end());</span><br><span class="line">  count++;</span><br><span class="line">  System.out.println(<span class="string">"found: "</span> + count + <span class="string">" : "</span>  + matcher.start() + <span class="string">" - "</span> + matcher.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们定义一个匹配to_date日期的正则表达式，通过每次调用find方法既可依次匹配到所有的。这里还需要对匹配的字符串进行替换，我们可以用String substring方法将需要的日期截取出来，然后使用正则表达式中的替换方法。</p><p>正则表达式的替换方法主要有以下几个：</p><p><code>1.replaceAll()</code></p><p><code>2.replaceFirst()</code></p><p><code>3.appendReplacement()</code></p><p><code>4.appendTail()</code></p><p>如果直接使用replaceFirst每次都只会替换第一个，而我们一行中有多个需要替换，如果使用replaceAll会一次将所有的替换为相同的，而我们每次替换的内容都不一样，所以需要进行动态替换，这里可以使用appendReplacement()和appendTail()方法。具体参考如下：<a href="http://ifeve.com/java-regex/" target="_blank" rel="noopener">http://ifeve.com/java-regex/</a></p><h2 id="关于读写大文件的问题"><a href="#关于读写大文件的问题" class="headerlink" title="关于读写大文件的问题"></a>关于读写大文件的问题</h2><h4 id="缓冲流读写"><a href="#缓冲流读写" class="headerlink" title="缓冲流读写"></a>缓冲流读写</h4><p>在对测试的小数据替换成功后就需要对整个大文件进行替换了。这里需要读取每行进行替换后并写入到新的文件里，如果每次读取一行就写如一行，由于频繁的IO操作会导致速度很慢。但如果一次性将其读取到StringBuffer里然后再一次写入，会因为数据量大而导致内存堆栈溢出。</p><p>相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line"> BufferedWriter bw = <span class="keyword">null</span>;</span><br><span class="line"> String line = <span class="keyword">null</span>;</span><br><span class="line"> StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">InputStreamReader read = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(rfileName)), <span class="string">"utf-8"</span>);</span><br><span class="line">br = <span class="keyword">new</span> BufferedReader(read);</span><br><span class="line"></span><br><span class="line">OutputStreamWriter write = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(wfileName)),<span class="string">"utf-8"</span>);        </span><br><span class="line">bw = <span class="keyword">new</span> BufferedWriter(write);</span><br><span class="line"><span class="keyword">while</span>((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="comment">//执行替换操作</span></span><br><span class="line">  ...</span><br><span class="line">  buf.append(line.toString()).append(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">bw.write(buf.toString());</span><br></pre></td></tr></table></figure><p>这里可以使用缓冲的读写，不带缓冲的操作，每读一个字节就要写入一个字节，由于涉及磁盘的IO操作相比内存的操作要慢很多，所以不带缓冲的流效率很低，带缓冲的流，可以一次读很多字节，但不向磁盘中写入，只是先放到内存里。等凑够了缓冲区大小的时候一次性写入磁盘，这种方式可以减少磁盘操作次数，速度就会提高很多！（注意需要调用flush方法刷新缓冲区）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(rfileName)));</span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(bis, <span class="string">"utf-8"</span>), <span class="number">20</span> * <span class="number">1024</span> * <span class="number">1024</span>);<span class="comment">// 20M缓存</span></span><br></pre></td></tr></table></figure><p>（需要注意编码的问题，否则中文会出现乱码）</p><h4 id="分割大文件"><a href="#分割大文件" class="headerlink" title="分割大文件"></a>分割大文件</h4><p>这里也可以将一个大文件按行分割成若干个文件，再分别对每个小文件进行处理。</p><p>相应代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> timer = System.currentTimeMillis();  </span><br><span class="line"> <span class="keyword">int</span> bufferSize = <span class="number">20</span> * <span class="number">1024</span> * <span class="number">1024</span>;<span class="comment">//设读取文件的缓存为20MB   </span></span><br><span class="line">   </span><br><span class="line"> <span class="comment">//建立缓冲文本输入流   </span></span><br><span class="line"> File file = <span class="keyword">new</span> File(<span class="string">"E:\\Code-Sublime\\Java\\jysg.sql"</span>);  </span><br><span class="line"> FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(file);  </span><br><span class="line"> BufferedInputStream bufferedInputStream = <span class="keyword">new</span> BufferedInputStream(fileInputStream);  </span><br><span class="line"> InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(bufferedInputStream, <span class="string">"gbk"</span>);  </span><br><span class="line"> BufferedReader input = <span class="keyword">new</span> BufferedReader(inputStreamReader, bufferSize);  </span><br><span class="line">   </span><br><span class="line"> <span class="keyword">int</span> splitNum = <span class="number">10</span>-<span class="number">1</span>;<span class="comment">//要分割的块数减一   </span></span><br><span class="line"> <span class="keyword">int</span> fileLines = <span class="number">920080</span>;<span class="comment">//输入文件的行数   </span></span><br><span class="line"> <span class="keyword">long</span> perSplitLines = fileLines / splitNum;<span class="comment">//每个块的行数   </span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= splitNum; ++i)  </span><br><span class="line"> &#123;  </span><br><span class="line">     <span class="comment">//分割   </span></span><br><span class="line">     <span class="comment">//每个块建立一个输出   </span></span><br><span class="line">     FileWriter output = <span class="keyword">new</span> FileWriter(<span class="string">"E:\\Code-Sublime\\Java\\split"</span> + i + <span class="string">".sql"</span>);  </span><br><span class="line">     String line = <span class="keyword">null</span>;  </span><br><span class="line">     <span class="comment">//逐行读取，逐行输出   </span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">long</span> lineCounter = <span class="number">0</span>; lineCounter &lt; perSplitLines &amp;&amp; (line = input.readLine()) != <span class="keyword">null</span>; ++lineCounter)  </span><br><span class="line">     &#123;  </span><br><span class="line">         output.append(line + <span class="string">"\r\n"</span>);  </span><br><span class="line">     &#125;  </span><br><span class="line">     output.flush();  </span><br><span class="line">     output.close();  </span><br><span class="line">     output = <span class="keyword">null</span>;  </span><br><span class="line"> &#125;  </span><br><span class="line"> input.close();  </span><br><span class="line"> timer = System.currentTimeMillis() - timer;  </span><br><span class="line"> System.out.println(<span class="string">"处理时间："</span> + timer);</span><br></pre></td></tr></table></figure><h2 id="总结和感想"><a href="#总结和感想" class="headerlink" title="总结和感想"></a>总结和感想</h2><p>学会发现和定位问题，并在规定时间内解决（不管用什么方法）</p><p>参考资料：</p><p><a href="http://ifeve.com/java-regex/" target="_blank" rel="noopener">http://ifeve.com/java-regex/</a></p><p><a href="https://blog.csdn.net/niyingxunzong/article/details/33335485" target="_blank" rel="noopener">https://blog.csdn.net/niyingxunzong/article/details/33335485</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在项目中需要读取sql文件，并修改里面的一部分内容。主要问题是sql文件里的插入语句中的日期是Oracle形式的，需要将其替换为Mysql形式的，其他的不变。项目中的sql文件有几十万条记录，数据量比较大，这可能在读取文件的时候带来一些问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./01.png&quot; style=&quot;zoom:60%&quot;&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，由于MySQL中没有to_date函数，而且里面的日期格式不对，也就是需要将画红线的部分替换为’2014-06-25’。（注意一行中有多个to_date）&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://litexy.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://litexy.com/tags/Java/"/>
    
      <category term="MySQL" scheme="http://litexy.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Servlet中的ServletConfig和ServletContext</title>
    <link href="http://litexy.com/2018/03/15/Servlet%E4%B8%AD%E7%9A%84ServletConfig%E5%92%8CServletContext/"/>
    <id>http://litexy.com/2018/03/15/Servlet中的ServletConfig和ServletContext/</id>
    <published>2018-03-15T08:49:52.000Z</published>
    <updated>2019-02-02T03:37:18.099Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习Servlet时，看到有些时候会用到ServletConfig和ServletContext两个类，而且这两个类还有点相似之处，所以写篇博客总结一下。首先看一下整个Servlet的层次结构。</p><p><img src="01.png" style="zoom: 80%"></p><a id="more"></a><p>基本上主要的和Servlet相关的类就这么多了，可以看到ServletConfig和ServletContext在其中的位置和其他类的关系。</p><h2 id="ServletConfig-API"><a href="#ServletConfig-API" class="headerlink" title="ServletConfig API"></a>ServletConfig API</h2><p>ServletConfig接口被用于传递一些配置信息给Servlet，每一个Servlet都独享一个自己的ServletConfig对象，然后servlet容器负责创建这个对象。我们可以在web.xml或者是WebInitParam注解方式设置一些servlet的初始参数信息，servlet通过得到ServletConfig对象实例调用其中的方法来得到这些初始信息。</p><p>常用的方法如下：</p><p><code>java.lang.String getInitParameter(java.lang.String name)  根据名称获取参数值</code></p><p><code>java.util.Enumeration getInitParameterNames()         得到所有参数</code></p><p><code>ServletContext getServletContext()                   获取servlet上下文对象</code></p><p><code>java.lang.String getServletName()                    得到servlet名称</code></p><p>通过在web.xml或注解中设置servlet初始参数，然后可以用上述方法获得这些参数：</p><p>web.xml配置文件:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>LoginServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.journaldev.servlet.LoginServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在web.xml中设置servlet初始参数(也可以使用注解方式) --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>user<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>xinyue<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><p>获取方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String user = getServletConfig().getInitParameter(<span class="string">"user"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里有个问题，为什么可以直接调用getServletConfig()方法，在Eclipse里Ctrl+鼠标点进去看发现调用的是GenericServlet类里的getServletConfig()方法。这是因为我们的Servlet类继承自HttpServlet，而HttpServlet又继承了GenericServlet类。</p></blockquote><p>GenericServlet类的定义如下：</p><p><img src="02.png" style="zoom:80%"></p><p>可以看到GenericServlet类中定义了ServletConfig对象的引用，而且还是实现了ServletConfig接口。</p><p><img src="03.png" style="zoom:80%"></p><p>其实也可以直接使用getInitParameter(“user”)，由于GenericServlet类实现了ServletConfig接口，所以其也会重载ServletConfig接口中的函数。</p><h2 id="ServletContext-API"><a href="#ServletContext-API" class="headerlink" title="ServletContext API"></a>ServletContext API</h2><p>不同于ServletConfig，ServletContext接口主要用于保存web应用中全局信息，所有Servlet都可以共享这些信息。其会在web应用被加载时创建，然后其他servlet就可以调用它了。</p><p>主要的方法如下:</p><p>（1）得到web应用的上下文路径：</p><p>​    <code>java.lang.String getContextPath()</code></p><p> （2）获取web应用的全局参数 ：         </p><p>　　 <code>java.lang.String getInitParameter(java.lang.String name)</code> </p><p>　　 <code>java.util.Enumeration getInitParameterNames()</code>  </p><p> （3）域对象相关的方法：</p><p>　　  <code>java.lang.Object getAttribute(java.lang.String name)</code>    </p><p>　　 <code>void setAttribute(java.lang.String name, java.lang.Object object)</code></p><p>　　 <code>void removeAttribute(java.lang.String name)</code></p><p> （4）用于转发：</p><p>　　  <code>RequestDispatcher getRequestDispatcher(java.lang.String path)</code>  </p><p> （5）web应用加载资源文件方法：</p><p>　　  <code>java.lang.String getRealPath(java.lang.String path)</code>   </p><p>　　  <code>java.io.InputStream getResourceAsStream(java.lang.String path)</code></p><h2 id="ServletConfig和ServletContext的应用"><a href="#ServletConfig和ServletContext的应用" class="headerlink" title="ServletConfig和ServletContext的应用"></a>ServletConfig和ServletContext的应用</h2><p>下面通过一个登陆的例子来看一下两者的用法，参考：<a href="https://www.journaldev.com/1877/servlet-tutorial-java#servlet-interface。" target="_blank" rel="noopener">https://www.journaldev.com/1877/servlet-tutorial-java#servlet-interface。</a></p><p>在html表单里请求LoginServlet，用户输入指定的用户名和密码即可登陆成功，跳转到登陆成功页面，失败则显示登陆失败。</p><p>我们主要讲解一下Servlet中的代码。首先在注解（或web.xml）中将用户名和密码作为servlet的初始参数存储（即前面讲ServletConfig相关的）：</p><p><img src="04.png" style="zoom:60%"></p><p>通过ServletContext中的方法获取web应用的全局配置信息：</p><p><img src="05.png" style="zoom:60%"></p><p>这里将数据库的配置作为全局信息，定义在web.xml文件的context-param中：</p><p><img src="06.png" style="60%"></p><p>在doPost方法中通过ServletConfig获取servlet的初始参数：</p><p><img src="07.png" style="zoom:60%"></p><p>如果登陆成功，通过sendRedirect方法重定向到LoginSuccess.jsp页面，否则转发到登陆页面。（这里要注意sendRedirect和getRequestDispatcher方法的区别）</p><h2 id="总结和感想"><a href="#总结和感想" class="headerlink" title="总结和感想"></a>总结和感想</h2><p>1.源码是最好的学习资料，遇到问题时，要学会从源码中寻找答案。包括类的层次结构和每个方法的作用。</p><p>2.在遇到一个新知识时，首先要知道这个知识涉及到哪些主要的类，这些类的关系是怎样的，然后再看每个类的方法。</p><p>参考资料：</p><p><a href="http://www.cnblogs.com/vmax-tam/p/4127396.html" target="_blank" rel="noopener">http://www.cnblogs.com/vmax-tam/p/4127396.html</a></p><p><a href="https://www.journaldev.com/1877/servlet-tutorial-java#servlet-interface" target="_blank" rel="noopener">https://www.journaldev.com/1877/servlet-tutorial-java#servlet-interface</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在学习Servlet时，看到有些时候会用到ServletConfig和ServletContext两个类，而且这两个类还有点相似之处，所以写篇博客总结一下。首先看一下整个Servlet的层次结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;01.png&quot; style=&quot;zoom: 80%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://litexy.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://litexy.com/tags/Java/"/>
    
      <category term="JavaWeb" scheme="http://litexy.com/tags/JavaWeb/"/>
    
      <category term="Servlet" scheme="http://litexy.com/tags/Servlet/"/>
    
  </entry>
  
  <entry>
    <title>关于链表题目的一些trick</title>
    <link href="http://litexy.com/2018/03/11/%E5%85%B3%E4%BA%8Eleetcode%E4%B8%8A%E9%93%BE%E8%A1%A8%E9%A2%98%E7%9B%AE%E7%9A%84%E4%B8%80%E4%BA%9Btrick/"/>
    <id>http://litexy.com/2018/03/11/关于leetcode上链表题目的一些trick/</id>
    <published>2018-03-11T10:12:03.000Z</published>
    <updated>2018-03-11T11:10:29.563Z</updated>
    
    <content type="html"><![CDATA[<p>最近在刷leetcode上关于链表的一些高频题，在写代码的过程中总结了链表的一些解题技巧和常见题型。</p><h2 id="结点的删除"><a href="#结点的删除" class="headerlink" title="结点的删除"></a>结点的删除</h2><p>指定链表中的某个结点，将其从链表中删除。</p><a id="more"></a><p>由于在链表中删除某个结点需要找到该结点的前一个位置，然后将前一个结点的next指针直接绕过该结点即可删除。但找到该结点的前一个位置需要指针遍历，其实还有一种更简单的trick，就是将要删除的结点的值设为该结点的后一个的值，然后删除该结点的后一个结点（间接删除，不需要找遍历前一个指针），代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        node.val = node.next.val;</span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在表头前增加虚拟结点"><a href="#在表头前增加虚拟结点" class="headerlink" title="在表头前增加虚拟结点"></a>在表头前增加虚拟结点</h2><p>很多场合下，在链表的表头前增加一个虚拟结点（dummy），并让其指向head，能简化很多操作。如在新创建一个链表或对链表进行遍历操作时，如果不增加虚拟结点，就需要处理当前结点是头结点的特殊情况（因为头结点前没有其他结点，导致操作代码不一致）。加了虚拟结点后就可以像操作其他结点一样对待头结点了，最后只需要返回虚拟结点的next就可以了。</p><p>如LeetCode上的这一题：<a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/" target="_blank" rel="noopener">Remove Nth Node From End of List</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode p = dummy;</span><br><span class="line">        ListNode q = dummy;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            q = q.next;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(q.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">            q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next = p.next.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表转置"><a href="#链表转置" class="headerlink" title="链表转置"></a>链表转置</h2><p>这应该是我碰到的链表中最频繁的问题了，很多其他链表的题目可能也需要借助于链表转置这一功能，所以需要能够熟练地写出代码，这里给出包括迭代和递归两种版本的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//迭代实现链表转置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next = head.next;</span><br><span class="line">            head.next = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归实现链表转置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode next = head.next;</span><br><span class="line">        <span class="comment">//对head.next执行转置</span></span><br><span class="line">        ListNode newHead = reverseList(next);</span><br><span class="line">        <span class="comment">//此时next变成了转置后的尾结点</span></span><br><span class="line">        next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快慢双指针"><a href="#快慢双指针" class="headerlink" title="快慢双指针"></a>快慢双指针</h2><p>有时候需要找到链表的中间位置的结点，这时就需要设置两个指针slow和fast，slow每次往前移动一个，fast移动两个。当fast为空时，slow就指向了链表的中间位置。比如leetcode上的<a href="https://leetcode.com/problems/palindrome-linked-list/description/" target="_blank" rel="noopener">Palindrome Linked List</a>在判断链表是否回文时，需要找到中间位置，然后将其后半部分转置和前半部分相比较，具体实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//注意不能直接转置整个链表，需要找到链表的中间，只转置后半部分</span></span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这时slow指向了链表的中间结点（注意这种trick要记住）</span></span><br><span class="line">        slow = reverseList(slow);</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span> &amp;&amp; slow != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(head.val != slow.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next = head.next;</span><br><span class="line">            head.next = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h2><p>这也是碰到的很常见的问题了，合并两个有序链表使其仍然保持有序，一般采用双指针法，这也需要能够熟练地写出无bug的代码来。这里给出迭代和递归两种实现方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span> &amp;&amp; l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode p = l1;</span><br><span class="line">        ListNode q = l2;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode pp = dummy;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span> &amp;&amp; q != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p.val &lt; q.val) &#123;</span><br><span class="line">                dummy.next = <span class="keyword">new</span> ListNode(p.val);</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dummy.next = <span class="keyword">new</span> ListNode(q.val);</span><br><span class="line">                q = q.next;</span><br><span class="line">            &#125;</span><br><span class="line">            dummy = dummy.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//直接将dummy指过去</span></span><br><span class="line">            dummy.next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">         <span class="keyword">if</span>(q != <span class="keyword">null</span>) &#123;</span><br><span class="line">             dummy.next = q;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用递归更简单</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists2</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l1.val&lt;l2.val)&#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next,l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1,l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前碰到的问题就这么多了，后面再继续补充吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在刷leetcode上关于链表的一些高频题，在写代码的过程中总结了链表的一些解题技巧和常见题型。&lt;/p&gt;
&lt;h2 id=&quot;结点的删除&quot;&gt;&lt;a href=&quot;#结点的删除&quot; class=&quot;headerlink&quot; title=&quot;结点的删除&quot;&gt;&lt;/a&gt;结点的删除&lt;/h2&gt;&lt;p&gt;指定链表中的某个结点，将其从链表中删除。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://litexy.com/categories/Algorithm/"/>
    
    
      <category term="LinkedList" scheme="http://litexy.com/tags/LinkedList/"/>
    
      <category term="Algorithm" scheme="http://litexy.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Sublime-text搭建Java编译环境</title>
    <link href="http://litexy.com/2018/02/04/Sublime-text%E6%90%AD%E5%BB%BAJava%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/"/>
    <id>http://litexy.com/2018/02/04/Sublime-text搭建Java编译环境/</id>
    <published>2018-02-04T10:28:21.000Z</published>
    <updated>2019-02-02T07:44:10.707Z</updated>
    
    <content type="html"><![CDATA[<p>以前运行Java代码都是在Eclipse或IDEA中进行，当开发大型项目的时候用这些IDE确实很方便，但有时候自己仅仅是像用Java写写简单的算法或小demo，这样每次打开这样大型的IDE太不方便了。于是想到了sublime text，之前只是用其搭建过C++和python的环境，没想到搭建Java也如此的方便强大，下面简单写下自己搭建的过程。</p><h2 id="搭建Java编译环境"><a href="#搭建Java编译环境" class="headerlink" title="搭建Java编译环境"></a>搭建Java编译环境</h2><p>在此之前请确保已配置好jdk环境变量。打开sublime text，依次点击Tools-&gt; Build System-&gt; New Build System，添加如下内容：</p><a id="more"></a><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 命令和参数，未指定路径则在PATH环境变量中找</span><br><span class="line">    "cmd": ["javac","-encoding","UTF-8","-d",".","$file"],</span><br><span class="line">    // 可选。获取cmd的错误输出</span><br><span class="line">    "file_regex": "^(...*?):([0-9]*):?([0-9]*)",</span><br><span class="line">    // 可选。`工具`菜单中`编译`为`自动`时生效</span><br><span class="line">    "selector": "source.java",</span><br><span class="line">    // 可选。输出"cmd"的编码。必须是合法的Python编码，缺省为"UTF-8"</span><br><span class="line">    "encoding":"UTF-8",</span><br><span class="line">    // variants 可选。用来替代主构建系统的备选。如果构建系统的"selector"与激活的文件匹配，变量"name"则会出现在 Command Palette 中。</span><br><span class="line">    "variants":</span><br><span class="line">        [</span><br><span class="line">            &#123;</span><br><span class="line">                 // 仅在"variants"中是合法的 (详见 variants)。用来标识系统中不同的构建系统。如果"name"是"Run" ,则会显示在Tools | Build System 菜单下，并且可以使用Ctrl + Shift + B调用</span><br><span class="line">                "name": "Run in cmd",</span><br><span class="line">                // 可选。如果该选项为"true" ，"cmd"则可以通过shell运行。</span><br><span class="line">                "shell": true,</span><br><span class="line">                "cmd" :  ["start","cmd","/c", "java $&#123;file_base_name&#125; &amp;echo. &amp; pause"],</span><br><span class="line">                "working_dir": "$&#123;file_path&#125;",</span><br><span class="line">                "encoding":"UTF-8"</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"name"</span>: <span class="string">"Run in sublime"</span>,</span><br><span class="line">                <span class="attr">"shell_cmd"</span>: <span class="string">"runJava.bat \"$file\""</span>,</span><br><span class="line">                <span class="attr">"file_regex"</span>: <span class="string">"^(...*?):([0-9]*):?([0-9]*)"</span>,</span><br><span class="line">                <span class="attr">"selector"</span>: <span class="string">"source.java"</span>,</span><br><span class="line">                <span class="attr">"encoding"</span>: <span class="string">"UTF-8"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里采用了两种方式，注意variants里的内容，其实配置C++等其他语言也是类似的。第一种我给的“name”为：Run in cmd，表示在控制台下运行，第二种为在sublime text中运行。ctrl-s保存，文件名我这里命名为MyJava。</p><p>其中在sublime text中运行时还要添加如下文件，在jdk的安装目录下的bin目录下新建runJava.bat文件，内容为：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> @echo off</span><br><span class="line"> cd%~dp1</span><br><span class="line"> echo Compiling %~nx1......</span><br><span class="line"> <span class="keyword">if</span> exist %~n1.class (</span><br><span class="line"> del %~n1.class</span><br><span class="line"> )</span><br><span class="line">javac %~nx1</span><br><span class="line"><span class="keyword">if</span> exist %~n1.class (</span><br><span class="line">echo ------Output------</span><br><span class="line">java %~n1</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>（注意在如果在sublime下运行则无法支持输入，在cmd中可以）</p><p>Ctrl+Shift+P选择运行方式：</p><p><img src="01.png" style="zoom:60%"></p><h2 id="Java代码提示补全"><a href="#Java代码提示补全" class="headerlink" title="Java代码提示补全"></a>Java代码提示补全</h2><p>光能编译运行还不够，最好还需要能够智能提示，这里推荐JavaIME插件，安装好即可使用，无需任何配置。具体演示如下：</p><p><img src="02.png" style="zoom:60%"></p><p>参考资料如下：<br><a href="https://packagecontrol.io/packages/JavaIME" target="_blank" rel="noopener">https://packagecontrol.io/packages/JavaIME</a></p><p><a href="https://www.zybuluo.com/king/note/47271#%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8Cjava" target="_blank" rel="noopener">https://www.zybuluo.com/king/note/47271#%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8Cjava</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前运行Java代码都是在Eclipse或IDEA中进行，当开发大型项目的时候用这些IDE确实很方便，但有时候自己仅仅是像用Java写写简单的算法或小demo，这样每次打开这样大型的IDE太不方便了。于是想到了sublime text，之前只是用其搭建过C++和python的环境，没想到搭建Java也如此的方便强大，下面简单写下自己搭建的过程。&lt;/p&gt;
&lt;h2 id=&quot;搭建Java编译环境&quot;&gt;&lt;a href=&quot;#搭建Java编译环境&quot; class=&quot;headerlink&quot; title=&quot;搭建Java编译环境&quot;&gt;&lt;/a&gt;搭建Java编译环境&lt;/h2&gt;&lt;p&gt;在此之前请确保已配置好jdk环境变量。打开sublime text，依次点击Tools-&amp;gt; Build System-&amp;gt; New Build System，添加如下内容：&lt;/p&gt;
    
    </summary>
    
      <category term="工具软件" scheme="http://litexy.com/categories/%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="Java" scheme="http://litexy.com/tags/Java/"/>
    
      <category term="sublime" scheme="http://litexy.com/tags/sublime/"/>
    
  </entry>
  
  <entry>
    <title>关于未来学习的一点定位和规划</title>
    <link href="http://litexy.com/2018/02/04/%E5%85%B3%E4%BA%8E%E6%9C%AA%E6%9D%A5%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%B8%80%E7%82%B9%E5%AE%9A%E4%BD%8D%E5%92%8C%E8%A7%84%E5%88%92/"/>
    <id>http://litexy.com/2018/02/04/关于未来学习的一点定位和规划/</id>
    <published>2018-02-04T03:03:08.000Z</published>
    <updated>2018-02-04T04:19:26.902Z</updated>
    
    <content type="html"><![CDATA[<p>思来想去有一段时间了，对于自己以后是走开发和算法也该有个结论了。两方面都花时间尝试了一下，虽然现在机器学习很热门，但其需要深厚的数学功底，否则也只是调得一手好参，无法深入下去。自己还是更喜欢丰富多样的业务场景，解决实际问题，相比于数学公式，还是更喜欢看源码。</p><p>对于开发，自己选择专攻后台开发这一方向，当然基本的开发素养和解决实际问题的能力是必不可少的 。语言可以是Java，当然不局限于语言，其实语言就像是程序员手中的武器，只要内力深厚，各种武器都可以发挥巨大威力。</p><a id="more"></a><h2 id="后台开发需要锻炼的技能"><a href="#后台开发需要锻炼的技能" class="headerlink" title="后台开发需要锻炼的技能"></a>后台开发需要锻炼的技能</h2><p>自己现在对后台开发还不是太了解，所以先暂时写一下自己所知道的，以后再慢慢补充和调整。针对后台开发，我目前觉得需要从以下几方面去着手逐一攻破：</p><p><strong>1.熟练掌握一门语言（这里选择Java）</strong>，包括该语言的各种特性。这就像是程序员的武器，没有武器或不熟悉自己的武器，如何在战场杀敌。</p><p><strong>2.基本的CS基础：网络、操作系统等，</strong>要理解其原理和如何应用在实际场景中。这就像是程序员使用的各种武功招式，不管武器如何变，招式都是一样的。</p><p><strong>3.算法和数据结构：</strong>灵活理解和掌握常用算法和数据结构，经常刷题。这就像是程序员的内功一样，有时候真正高手的差别就体现在这里。</p><p><strong>4.常用开发环境以及框架：</strong>包括IDE、Linux等开发环境的熟悉，SSM等基本框架的掌握。这就像是程序员以后要面临的战场环境，决胜沙场就在此处了。</p><p><strong>5.架构和实际业务场景有关的：</strong>如分布式、高并发，负载均衡等，这部分也需要重点掌握，面试时会是加分项（自己的项目一般不会用到，但大公司都会，这里可以关注阿里、美团等电商在架构和效率提升上的一些技术）。这就像是高级的武功秘籍一样，掌握了就可以一敌百（想想乔帮主的降龙十八掌）.</p><p><strong>6.一些拓展, 保持眼界和学习新技术的热情: </strong>可以关注当下的一些热点技术(如机器学习 大数据等) 也不需要盲目的去学习, 对于能用到的可以适当采用. 这就像是武学里常说的”练一家, 观百家”, 需要对技术的发展保持一个整体的眼界, 不至于落后.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面所罗列的只是一个整体的方向,对于每一条都需要详细制定出具体的学习计划. 希望自己能力去遵循, 逐一攻破,不能再犹犹豫豫,踌躇不前, 努力排除外界干扰, 不为外界所动. </p><p>其实以前太在意能够寻找一些捷径和快速的方法去学习, 以致于都无法静下心来去攻读一本好书.  其实最简单高效的学习方法就是: 多读好书, 多看源码, 多实践, 多总结, 多思考. 希望自己在接下来的时间里能够沉淀下来学习.</p><p>坚持内心 , 无问西东 !</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;思来想去有一段时间了，对于自己以后是走开发和算法也该有个结论了。两方面都花时间尝试了一下，虽然现在机器学习很热门，但其需要深厚的数学功底，否则也只是调得一手好参，无法深入下去。自己还是更喜欢丰富多样的业务场景，解决实际问题，相比于数学公式，还是更喜欢看源码。&lt;/p&gt;
&lt;p&gt;对于开发，自己选择专攻后台开发这一方向，当然基本的开发素养和解决实际问题的能力是必不可少的 。语言可以是Java，当然不局限于语言，其实语言就像是程序员手中的武器，只要内力深厚，各种武器都可以发挥巨大威力。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://litexy.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://litexy.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>阿里云服务器部署Java Web项目全过程</title>
    <link href="http://litexy.com/2018/01/30/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2Web%E9%A1%B9%E7%9B%AE/"/>
    <id>http://litexy.com/2018/01/30/阿里云服务器部署Web项目/</id>
    <published>2018-01-30T12:05:08.000Z</published>
    <updated>2018-12-14T16:52:19.051Z</updated>
    
    <content type="html"><![CDATA[<p>最近需要将一个Java Web项目部署到服务器上，方便多人共享访问。这也是我第一次接触服务器之类的东西，也花了一点时间，最终总算部署成功，写下一篇文章记录以便日后回顾。</p><h2 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h2><p>第一步当然是需要购买一台服务器了，我选择的是阿里云的ECS，对于新用户有一定的优惠活动。服务器徐购好后可以在管理控制台下看到自己服务器的配置情况。我买的是centos7 1核2G的，详情如下：</p><p><img src="7.jpg" style="zoom:60%"></p><a id="more"></a><h2 id="本地主机连接服务器"><a href="#本地主机连接服务器" class="headerlink" title="本地主机连接服务器"></a>本地主机连接服务器</h2><p>购买了服务器之后，下一步当时是要远程操作服务器，所以需要和远程服务器建立连接。这里有两种方式：一种是使用阿里云控制中心自带的管理终端进行远程连接，另一种是使用熟知的ssh协议。</p><h3 id="使用管理终端连接"><a href="#使用管理终端连接" class="headerlink" title="使用管理终端连接"></a>使用管理终端连接</h3><p>登陆ECS控制台，单击左侧导航栏里的实例，右边有一个远程连接选项</p><p><img src="2.jpg" style="zoom:60%"> </p><p>注意第一次登陆时会分配一个密码，将其记住，下次需要用这个密码登陆，登陆后的界面如下所示：</p><p><img src="3.jpg" style="zoom:60%"></p><h3 id="使用ssh连接"><a href="#使用ssh连接" class="headerlink" title="使用ssh连接"></a>使用ssh连接</h3><p>windows下需要下载putty工具，需要用puttygen生成密钥对，具体可参见：</p><p><a href="https://help.aliyun.com/document_detail/51798.html?spm=5176.doc25425.2.11.Fe06aK" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/51798.html?spm=5176.doc25425.2.11.Fe06aK</a></p><p><img src="4.jpg" style="zoom:60%"></p><h2 id="搭建Java-Web开发环境"><a href="#搭建Java-Web开发环境" class="headerlink" title="搭建Java Web开发环境"></a>搭建Java Web开发环境</h2><p>接下来需要在远程centos服务器上搭建Java Web开发环境，这里可以选择镜像部署和手工部署，阿里云上提供了很多相关环境的镜像，我这里使用手动部署的方式自己安装软件。部署Java Web需要分别安装配置jdk、tomcat、mysql，我创建了一个用户，并给该用户授权sudo。在该用户的目录下分布创建java、tomcat和mysql目录用于存放相应的软件和文件。</p><h3 id="JDK配置"><a href="#JDK配置" class="headerlink" title="JDK配置"></a>JDK配置</h3><p>可以在官网上或使用命令wget下载相应版本的jdk安装包，由于我的本地项目使用的是jdk8，所以这里也下载对应的版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirrors.linuxeye.com/jdk/jdk-8u144-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><p>将其解压到安装目录，我这里是/home/vcc/java</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xzf jdk-8u144-linux-x64.tar.gz -C /home/vcc/java</span><br></pre></td></tr></table></figure><p>设置环境变量：</p><p>编辑/etc/profile文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/profile</span><br></pre></td></tr></table></figure><p>进入编辑模式后在最后添加如下信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>set java environment</span><br><span class="line">export JAVA_HOME=/home/vcc/java/jdk1.8.0_144</span><br><span class="line">export CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br></pre></td></tr></table></figure><p>保存后退出，加载环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>查看jdk版本：</p><p><img src="5.jpg" style="zoom:60%"></p><h3 id="tomcat安装配置"><a href="#tomcat安装配置" class="headerlink" title="tomcat安装配置"></a>tomcat安装配置</h3><p>tomcat的安装和jdk类似，需要注意要想在外部使用服务器的ip地址访问，需要在阿里云安全组规则中允许8080端口通过，详情如下：</p><p><img src="6.jpg" style="zoom:60%"></p><p>注意在前面ssh连接中也需要设置安全组规则，配置好，在本机输入ip地址:8080即可访问tomcat页面，表明配置成功，具体可参见阿里云官方文档：</p><p><a href="https://help.aliyun.com/document_detail/51376.html?spm=5176.doc52806.6.757.bJq7gM" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/51376.html?spm=5176.doc52806.6.757.bJq7gM</a></p><h3 id="mysql安装配置"><a href="#mysql安装配置" class="headerlink" title="mysql安装配置"></a>mysql安装配置</h3><p>本来想安装mysql5.7的，结果安装过程中总是出现问题，就该换mysql5.6了，安装教程网上应该有很多，这里就不多说了。安装好后运行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysqld start</span><br></pre></td></tr></table></figure><p>启动mysql后，运行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>使用root用户登陆mysql。</p><h2 id="部署Java-Web项目"><a href="#部署Java-Web项目" class="headerlink" title="部署Java Web项目"></a>部署Java Web项目</h2><p>我需要将本地的Java Web工程打包成war，以及将数据库导出至sql文件一并上传到服务器上。这里可以使用pscp工具进行本地主机和服务器之间文件的上传和下载，需要下载pscp并和putty放在同一目录下，cmd进入到putty目录，使用命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pscp E:\data.sql root@ip地址:/home/vcc/mysql</span><br></pre></td></tr></table></figure><p>将项目的war包放到tomcat的webapps目录下，tomcat运行后会自动将其解压，然后就可以使用路径来访问了。</p><p>对于数据库的导入，需要在mysql命令下先创建同名的数据库，然后使用source data.sql运行即可。这里要注意需要将MySQL客户端和服务器端的编码都设置为utf8，否则在部署访问的时候会出现问题。这里可以通过修改/etc/my.cnf文件：</p><p><img src="8.jpg" style="zoom:60%"></p><p>在本机上成功访问项目：</p><p><img src="9.jpg" style="zoom:60%"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近需要将一个Java Web项目部署到服务器上，方便多人共享访问。这也是我第一次接触服务器之类的东西，也花了一点时间，最终总算部署成功，写下一篇文章记录以便日后回顾。&lt;/p&gt;
&lt;h2 id=&quot;购买服务器&quot;&gt;&lt;a href=&quot;#购买服务器&quot; class=&quot;headerlink&quot; title=&quot;购买服务器&quot;&gt;&lt;/a&gt;购买服务器&lt;/h2&gt;&lt;p&gt;第一步当然是需要购买一台服务器了，我选择的是阿里云的ECS，对于新用户有一定的优惠活动。服务器徐购好后可以在管理控制台下看到自己服务器的配置情况。我买的是centos7 1核2G的，详情如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;7.jpg&quot; style=&quot;zoom:60%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://litexy.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="JavaWeb" scheme="http://litexy.com/tags/JavaWeb/"/>
    
      <category term="阿里云" scheme="http://litexy.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
  </entry>
  
</feed>
